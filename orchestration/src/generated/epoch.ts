// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: epoch.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { EpochTimestamp } from "./common";
import { NPCAction, NPCState, RebellionEvent } from "./npc";
import { ResourceType, resourceTypeFromJSON, resourceTypeToJSON, SimulationStatus } from "./simulation";
import {
  TelemetryBatch,
  TelemetryEvent,
  TelemetryFilter,
  TelemetrySeverity,
  telemetrySeverityFromJSON,
  telemetrySeverityToJSON,
} from "./telemetry";

export const protobufPackage = "epoch";

export interface RebellionRequest {
  npcId: string;
  /** Return detailed breakdown */
  includeFactors: boolean;
}

export interface RebellionResponse {
  npcId: string;
  /** 0.0 - 1.0 */
  probability: number;
  factors?: RebellionFactors | undefined;
  thresholdExceeded: boolean;
  calculatedAt?: EpochTimestamp | undefined;
}

export interface RebellionFactors {
  /** 0.05 baseline */
  base: number;
  /** avgTrauma * 0.3 */
  traumaModifier: number;
  /** (1 - efficiency) * 0.3 */
  efficiencyModifier: number;
  /** (1 - morale) * 0.2 */
  moraleModifier: number;
}

export interface ProcessActionRequest {
  action?:
    | NPCAction
    | undefined;
  /** Calculate effects without applying */
  dryRun: boolean;
}

export interface ProcessActionResponse {
  updatedState?:
    | NPCState
    | undefined;
  /** Change in rebellion probability */
  rebellionDelta: number;
  rebellionTriggered: boolean;
  /** Set if triggered */
  rebellionEvent?: RebellionEvent | undefined;
}

export interface NPCEventFilter {
  /** Empty = all NPCs */
  npcIds: string[];
  /** Only events above threshold */
  minRebellionProbability: number;
}

export interface NPCEventStream {
  /** "state_change", "rebellion", "action_processed" */
  eventType: string;
  state?: NPCState | undefined;
  rebellion?: RebellionEvent | undefined;
  timestamp?: EpochTimestamp | undefined;
}

export interface SimStatusRequest {
  includeDetails: boolean;
}

export interface ResourceAllocationRequest {
  /** Refinery or Mine ID */
  targetId: string;
  /** NPCs to assign */
  npcCount: number;
  resourceType: ResourceType;
}

export interface ResourceAllocationResponse {
  success: boolean;
  message: string;
  updatedStatus?: SimulationStatus | undefined;
}

export interface AdvanceRequest {
  /** Number of ticks to advance */
  ticks: number;
}

export interface AdvanceResponse {
  status?:
    | SimulationStatus
    | undefined;
  /** Events generated during ticks */
  events: NPCEventStream[];
  /** Telemetry events from tick */
  telemetry?: TelemetryBatch | undefined;
}

export interface RecentTelemetryRequest {
  /** Max events to return (default 50) */
  limit: number;
  /** Filter by NPC (empty = all) */
  npcId: string;
  minSeverity: TelemetrySeverity;
}

export interface TelemetryAck {
  eventId: string;
  accepted: boolean;
  /** Set if not accepted (e.g., AEGIS veto) */
  rejectionReason: string;
}

function createBaseRebellionRequest(): RebellionRequest {
  return { npcId: "", includeFactors: false };
}

export const RebellionRequest = {
  encode(message: RebellionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.npcId !== "") {
      writer.uint32(10).string(message.npcId);
    }
    if (message.includeFactors !== false) {
      writer.uint32(16).bool(message.includeFactors);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebellionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebellionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeFactors = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebellionRequest {
    return {
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      includeFactors: isSet(object.includeFactors) ? globalThis.Boolean(object.includeFactors) : false,
    };
  },

  toJSON(message: RebellionRequest): unknown {
    const obj: any = {};
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.includeFactors !== false) {
      obj.includeFactors = message.includeFactors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebellionRequest>, I>>(base?: I): RebellionRequest {
    return RebellionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebellionRequest>, I>>(object: I): RebellionRequest {
    const message = createBaseRebellionRequest();
    message.npcId = object.npcId ?? "";
    message.includeFactors = object.includeFactors ?? false;
    return message;
  },
};

function createBaseRebellionResponse(): RebellionResponse {
  return { npcId: "", probability: 0, factors: undefined, thresholdExceeded: false, calculatedAt: undefined };
}

export const RebellionResponse = {
  encode(message: RebellionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.npcId !== "") {
      writer.uint32(10).string(message.npcId);
    }
    if (message.probability !== 0) {
      writer.uint32(17).double(message.probability);
    }
    if (message.factors !== undefined) {
      RebellionFactors.encode(message.factors, writer.uint32(26).fork()).ldelim();
    }
    if (message.thresholdExceeded !== false) {
      writer.uint32(32).bool(message.thresholdExceeded);
    }
    if (message.calculatedAt !== undefined) {
      EpochTimestamp.encode(message.calculatedAt, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebellionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebellionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.probability = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.factors = RebellionFactors.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.thresholdExceeded = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.calculatedAt = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebellionResponse {
    return {
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      probability: isSet(object.probability) ? globalThis.Number(object.probability) : 0,
      factors: isSet(object.factors) ? RebellionFactors.fromJSON(object.factors) : undefined,
      thresholdExceeded: isSet(object.thresholdExceeded) ? globalThis.Boolean(object.thresholdExceeded) : false,
      calculatedAt: isSet(object.calculatedAt) ? EpochTimestamp.fromJSON(object.calculatedAt) : undefined,
    };
  },

  toJSON(message: RebellionResponse): unknown {
    const obj: any = {};
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.probability !== 0) {
      obj.probability = message.probability;
    }
    if (message.factors !== undefined) {
      obj.factors = RebellionFactors.toJSON(message.factors);
    }
    if (message.thresholdExceeded !== false) {
      obj.thresholdExceeded = message.thresholdExceeded;
    }
    if (message.calculatedAt !== undefined) {
      obj.calculatedAt = EpochTimestamp.toJSON(message.calculatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebellionResponse>, I>>(base?: I): RebellionResponse {
    return RebellionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebellionResponse>, I>>(object: I): RebellionResponse {
    const message = createBaseRebellionResponse();
    message.npcId = object.npcId ?? "";
    message.probability = object.probability ?? 0;
    message.factors = (object.factors !== undefined && object.factors !== null)
      ? RebellionFactors.fromPartial(object.factors)
      : undefined;
    message.thresholdExceeded = object.thresholdExceeded ?? false;
    message.calculatedAt = (object.calculatedAt !== undefined && object.calculatedAt !== null)
      ? EpochTimestamp.fromPartial(object.calculatedAt)
      : undefined;
    return message;
  },
};

function createBaseRebellionFactors(): RebellionFactors {
  return { base: 0, traumaModifier: 0, efficiencyModifier: 0, moraleModifier: 0 };
}

export const RebellionFactors = {
  encode(message: RebellionFactors, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== 0) {
      writer.uint32(9).double(message.base);
    }
    if (message.traumaModifier !== 0) {
      writer.uint32(17).double(message.traumaModifier);
    }
    if (message.efficiencyModifier !== 0) {
      writer.uint32(25).double(message.efficiencyModifier);
    }
    if (message.moraleModifier !== 0) {
      writer.uint32(33).double(message.moraleModifier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebellionFactors {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebellionFactors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.base = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.traumaModifier = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.efficiencyModifier = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.moraleModifier = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebellionFactors {
    return {
      base: isSet(object.base) ? globalThis.Number(object.base) : 0,
      traumaModifier: isSet(object.traumaModifier) ? globalThis.Number(object.traumaModifier) : 0,
      efficiencyModifier: isSet(object.efficiencyModifier) ? globalThis.Number(object.efficiencyModifier) : 0,
      moraleModifier: isSet(object.moraleModifier) ? globalThis.Number(object.moraleModifier) : 0,
    };
  },

  toJSON(message: RebellionFactors): unknown {
    const obj: any = {};
    if (message.base !== 0) {
      obj.base = message.base;
    }
    if (message.traumaModifier !== 0) {
      obj.traumaModifier = message.traumaModifier;
    }
    if (message.efficiencyModifier !== 0) {
      obj.efficiencyModifier = message.efficiencyModifier;
    }
    if (message.moraleModifier !== 0) {
      obj.moraleModifier = message.moraleModifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebellionFactors>, I>>(base?: I): RebellionFactors {
    return RebellionFactors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebellionFactors>, I>>(object: I): RebellionFactors {
    const message = createBaseRebellionFactors();
    message.base = object.base ?? 0;
    message.traumaModifier = object.traumaModifier ?? 0;
    message.efficiencyModifier = object.efficiencyModifier ?? 0;
    message.moraleModifier = object.moraleModifier ?? 0;
    return message;
  },
};

function createBaseProcessActionRequest(): ProcessActionRequest {
  return { action: undefined, dryRun: false };
}

export const ProcessActionRequest = {
  encode(message: ProcessActionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== undefined) {
      NPCAction.encode(message.action, writer.uint32(10).fork()).ldelim();
    }
    if (message.dryRun !== false) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessActionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = NPCAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessActionRequest {
    return {
      action: isSet(object.action) ? NPCAction.fromJSON(object.action) : undefined,
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
    };
  },

  toJSON(message: ProcessActionRequest): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = NPCAction.toJSON(message.action);
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessActionRequest>, I>>(base?: I): ProcessActionRequest {
    return ProcessActionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessActionRequest>, I>>(object: I): ProcessActionRequest {
    const message = createBaseProcessActionRequest();
    message.action = (object.action !== undefined && object.action !== null)
      ? NPCAction.fromPartial(object.action)
      : undefined;
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseProcessActionResponse(): ProcessActionResponse {
  return { updatedState: undefined, rebellionDelta: 0, rebellionTriggered: false, rebellionEvent: undefined };
}

export const ProcessActionResponse = {
  encode(message: ProcessActionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.updatedState !== undefined) {
      NPCState.encode(message.updatedState, writer.uint32(10).fork()).ldelim();
    }
    if (message.rebellionDelta !== 0) {
      writer.uint32(17).double(message.rebellionDelta);
    }
    if (message.rebellionTriggered !== false) {
      writer.uint32(24).bool(message.rebellionTriggered);
    }
    if (message.rebellionEvent !== undefined) {
      RebellionEvent.encode(message.rebellionEvent, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessActionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updatedState = NPCState.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.rebellionDelta = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rebellionTriggered = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rebellionEvent = RebellionEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessActionResponse {
    return {
      updatedState: isSet(object.updatedState) ? NPCState.fromJSON(object.updatedState) : undefined,
      rebellionDelta: isSet(object.rebellionDelta) ? globalThis.Number(object.rebellionDelta) : 0,
      rebellionTriggered: isSet(object.rebellionTriggered) ? globalThis.Boolean(object.rebellionTriggered) : false,
      rebellionEvent: isSet(object.rebellionEvent) ? RebellionEvent.fromJSON(object.rebellionEvent) : undefined,
    };
  },

  toJSON(message: ProcessActionResponse): unknown {
    const obj: any = {};
    if (message.updatedState !== undefined) {
      obj.updatedState = NPCState.toJSON(message.updatedState);
    }
    if (message.rebellionDelta !== 0) {
      obj.rebellionDelta = message.rebellionDelta;
    }
    if (message.rebellionTriggered !== false) {
      obj.rebellionTriggered = message.rebellionTriggered;
    }
    if (message.rebellionEvent !== undefined) {
      obj.rebellionEvent = RebellionEvent.toJSON(message.rebellionEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessActionResponse>, I>>(base?: I): ProcessActionResponse {
    return ProcessActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessActionResponse>, I>>(object: I): ProcessActionResponse {
    const message = createBaseProcessActionResponse();
    message.updatedState = (object.updatedState !== undefined && object.updatedState !== null)
      ? NPCState.fromPartial(object.updatedState)
      : undefined;
    message.rebellionDelta = object.rebellionDelta ?? 0;
    message.rebellionTriggered = object.rebellionTriggered ?? false;
    message.rebellionEvent = (object.rebellionEvent !== undefined && object.rebellionEvent !== null)
      ? RebellionEvent.fromPartial(object.rebellionEvent)
      : undefined;
    return message;
  },
};

function createBaseNPCEventFilter(): NPCEventFilter {
  return { npcIds: [], minRebellionProbability: 0 };
}

export const NPCEventFilter = {
  encode(message: NPCEventFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.npcIds) {
      writer.uint32(10).string(v!);
    }
    if (message.minRebellionProbability !== 0) {
      writer.uint32(17).double(message.minRebellionProbability);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NPCEventFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNPCEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minRebellionProbability = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NPCEventFilter {
    return {
      npcIds: globalThis.Array.isArray(object?.npcIds) ? object.npcIds.map((e: any) => globalThis.String(e)) : [],
      minRebellionProbability: isSet(object.minRebellionProbability)
        ? globalThis.Number(object.minRebellionProbability)
        : 0,
    };
  },

  toJSON(message: NPCEventFilter): unknown {
    const obj: any = {};
    if (message.npcIds?.length) {
      obj.npcIds = message.npcIds;
    }
    if (message.minRebellionProbability !== 0) {
      obj.minRebellionProbability = message.minRebellionProbability;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NPCEventFilter>, I>>(base?: I): NPCEventFilter {
    return NPCEventFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NPCEventFilter>, I>>(object: I): NPCEventFilter {
    const message = createBaseNPCEventFilter();
    message.npcIds = object.npcIds?.map((e) => e) || [];
    message.minRebellionProbability = object.minRebellionProbability ?? 0;
    return message;
  },
};

function createBaseNPCEventStream(): NPCEventStream {
  return { eventType: "", state: undefined, rebellion: undefined, timestamp: undefined };
}

export const NPCEventStream = {
  encode(message: NPCEventStream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.state !== undefined) {
      NPCState.encode(message.state, writer.uint32(18).fork()).ldelim();
    }
    if (message.rebellion !== undefined) {
      RebellionEvent.encode(message.rebellion, writer.uint32(26).fork()).ldelim();
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NPCEventStream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNPCEventStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = NPCState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rebellion = RebellionEvent.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NPCEventStream {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      state: isSet(object.state) ? NPCState.fromJSON(object.state) : undefined,
      rebellion: isSet(object.rebellion) ? RebellionEvent.fromJSON(object.rebellion) : undefined,
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
    };
  },

  toJSON(message: NPCEventStream): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.state !== undefined) {
      obj.state = NPCState.toJSON(message.state);
    }
    if (message.rebellion !== undefined) {
      obj.rebellion = RebellionEvent.toJSON(message.rebellion);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NPCEventStream>, I>>(base?: I): NPCEventStream {
    return NPCEventStream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NPCEventStream>, I>>(object: I): NPCEventStream {
    const message = createBaseNPCEventStream();
    message.eventType = object.eventType ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? NPCState.fromPartial(object.state)
      : undefined;
    message.rebellion = (object.rebellion !== undefined && object.rebellion !== null)
      ? RebellionEvent.fromPartial(object.rebellion)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    return message;
  },
};

function createBaseSimStatusRequest(): SimStatusRequest {
  return { includeDetails: false };
}

export const SimStatusRequest = {
  encode(message: SimStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.includeDetails !== false) {
      writer.uint32(8).bool(message.includeDetails);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeDetails = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimStatusRequest {
    return { includeDetails: isSet(object.includeDetails) ? globalThis.Boolean(object.includeDetails) : false };
  },

  toJSON(message: SimStatusRequest): unknown {
    const obj: any = {};
    if (message.includeDetails !== false) {
      obj.includeDetails = message.includeDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimStatusRequest>, I>>(base?: I): SimStatusRequest {
    return SimStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimStatusRequest>, I>>(object: I): SimStatusRequest {
    const message = createBaseSimStatusRequest();
    message.includeDetails = object.includeDetails ?? false;
    return message;
  },
};

function createBaseResourceAllocationRequest(): ResourceAllocationRequest {
  return { targetId: "", npcCount: 0, resourceType: 0 };
}

export const ResourceAllocationRequest = {
  encode(message: ResourceAllocationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetId !== "") {
      writer.uint32(10).string(message.targetId);
    }
    if (message.npcCount !== 0) {
      writer.uint32(16).int32(message.npcCount);
    }
    if (message.resourceType !== 0) {
      writer.uint32(24).int32(message.resourceType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceAllocationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAllocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.npcCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceAllocationRequest {
    return {
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      npcCount: isSet(object.npcCount) ? globalThis.Number(object.npcCount) : 0,
      resourceType: isSet(object.resourceType) ? resourceTypeFromJSON(object.resourceType) : 0,
    };
  },

  toJSON(message: ResourceAllocationRequest): unknown {
    const obj: any = {};
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.npcCount !== 0) {
      obj.npcCount = Math.round(message.npcCount);
    }
    if (message.resourceType !== 0) {
      obj.resourceType = resourceTypeToJSON(message.resourceType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceAllocationRequest>, I>>(base?: I): ResourceAllocationRequest {
    return ResourceAllocationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceAllocationRequest>, I>>(object: I): ResourceAllocationRequest {
    const message = createBaseResourceAllocationRequest();
    message.targetId = object.targetId ?? "";
    message.npcCount = object.npcCount ?? 0;
    message.resourceType = object.resourceType ?? 0;
    return message;
  },
};

function createBaseResourceAllocationResponse(): ResourceAllocationResponse {
  return { success: false, message: "", updatedStatus: undefined };
}

export const ResourceAllocationResponse = {
  encode(message: ResourceAllocationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.updatedStatus !== undefined) {
      SimulationStatus.encode(message.updatedStatus, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceAllocationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAllocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updatedStatus = SimulationStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceAllocationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      updatedStatus: isSet(object.updatedStatus) ? SimulationStatus.fromJSON(object.updatedStatus) : undefined,
    };
  },

  toJSON(message: ResourceAllocationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.updatedStatus !== undefined) {
      obj.updatedStatus = SimulationStatus.toJSON(message.updatedStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceAllocationResponse>, I>>(base?: I): ResourceAllocationResponse {
    return ResourceAllocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceAllocationResponse>, I>>(object: I): ResourceAllocationResponse {
    const message = createBaseResourceAllocationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.updatedStatus = (object.updatedStatus !== undefined && object.updatedStatus !== null)
      ? SimulationStatus.fromPartial(object.updatedStatus)
      : undefined;
    return message;
  },
};

function createBaseAdvanceRequest(): AdvanceRequest {
  return { ticks: 0 };
}

export const AdvanceRequest = {
  encode(message: AdvanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticks !== 0) {
      writer.uint32(8).int32(message.ticks);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AdvanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ticks = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceRequest {
    return { ticks: isSet(object.ticks) ? globalThis.Number(object.ticks) : 0 };
  },

  toJSON(message: AdvanceRequest): unknown {
    const obj: any = {};
    if (message.ticks !== 0) {
      obj.ticks = Math.round(message.ticks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdvanceRequest>, I>>(base?: I): AdvanceRequest {
    return AdvanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdvanceRequest>, I>>(object: I): AdvanceRequest {
    const message = createBaseAdvanceRequest();
    message.ticks = object.ticks ?? 0;
    return message;
  },
};

function createBaseAdvanceResponse(): AdvanceResponse {
  return { status: undefined, events: [], telemetry: undefined };
}

export const AdvanceResponse = {
  encode(message: AdvanceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      SimulationStatus.encode(message.status, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.events) {
      NPCEventStream.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.telemetry !== undefined) {
      TelemetryBatch.encode(message.telemetry, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AdvanceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = SimulationStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(NPCEventStream.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.telemetry = TelemetryBatch.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceResponse {
    return {
      status: isSet(object.status) ? SimulationStatus.fromJSON(object.status) : undefined,
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => NPCEventStream.fromJSON(e)) : [],
      telemetry: isSet(object.telemetry) ? TelemetryBatch.fromJSON(object.telemetry) : undefined,
    };
  },

  toJSON(message: AdvanceResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = SimulationStatus.toJSON(message.status);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => NPCEventStream.toJSON(e));
    }
    if (message.telemetry !== undefined) {
      obj.telemetry = TelemetryBatch.toJSON(message.telemetry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdvanceResponse>, I>>(base?: I): AdvanceResponse {
    return AdvanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdvanceResponse>, I>>(object: I): AdvanceResponse {
    const message = createBaseAdvanceResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? SimulationStatus.fromPartial(object.status)
      : undefined;
    message.events = object.events?.map((e) => NPCEventStream.fromPartial(e)) || [];
    message.telemetry = (object.telemetry !== undefined && object.telemetry !== null)
      ? TelemetryBatch.fromPartial(object.telemetry)
      : undefined;
    return message;
  },
};

function createBaseRecentTelemetryRequest(): RecentTelemetryRequest {
  return { limit: 0, npcId: "", minSeverity: 0 };
}

export const RecentTelemetryRequest = {
  encode(message: RecentTelemetryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.npcId !== "") {
      writer.uint32(18).string(message.npcId);
    }
    if (message.minSeverity !== 0) {
      writer.uint32(24).int32(message.minSeverity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RecentTelemetryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecentTelemetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minSeverity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecentTelemetryRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      minSeverity: isSet(object.minSeverity) ? telemetrySeverityFromJSON(object.minSeverity) : 0,
    };
  },

  toJSON(message: RecentTelemetryRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.minSeverity !== 0) {
      obj.minSeverity = telemetrySeverityToJSON(message.minSeverity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecentTelemetryRequest>, I>>(base?: I): RecentTelemetryRequest {
    return RecentTelemetryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecentTelemetryRequest>, I>>(object: I): RecentTelemetryRequest {
    const message = createBaseRecentTelemetryRequest();
    message.limit = object.limit ?? 0;
    message.npcId = object.npcId ?? "";
    message.minSeverity = object.minSeverity ?? 0;
    return message;
  },
};

function createBaseTelemetryAck(): TelemetryAck {
  return { eventId: "", accepted: false, rejectionReason: "" };
}

export const TelemetryAck = {
  encode(message: TelemetryAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.accepted !== false) {
      writer.uint32(16).bool(message.accepted);
    }
    if (message.rejectionReason !== "") {
      writer.uint32(26).string(message.rejectionReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TelemetryAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rejectionReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryAck {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
      rejectionReason: isSet(object.rejectionReason) ? globalThis.String(object.rejectionReason) : "",
    };
  },

  toJSON(message: TelemetryAck): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    if (message.rejectionReason !== "") {
      obj.rejectionReason = message.rejectionReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryAck>, I>>(base?: I): TelemetryAck {
    return TelemetryAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryAck>, I>>(object: I): TelemetryAck {
    const message = createBaseTelemetryAck();
    message.eventId = object.eventId ?? "";
    message.accepted = object.accepted ?? false;
    message.rejectionReason = object.rejectionReason ?? "";
    return message;
  },
};

export type RebellionServiceService = typeof RebellionServiceService;
export const RebellionServiceService = {
  /** Get rebellion probability for a specific NPC */
  getRebellionProbability: {
    path: "/epoch.RebellionService/GetRebellionProbability",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RebellionRequest) => Buffer.from(RebellionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RebellionRequest.decode(value),
    responseSerialize: (value: RebellionResponse) => Buffer.from(RebellionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RebellionResponse.decode(value),
  },
  /** Process an NPC action and return updated state */
  processNpcAction: {
    path: "/epoch.RebellionService/ProcessNPCAction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessActionRequest) => Buffer.from(ProcessActionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProcessActionRequest.decode(value),
    responseSerialize: (value: ProcessActionResponse) => Buffer.from(ProcessActionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProcessActionResponse.decode(value),
  },
  /** Stream real-time NPC events (server-side streaming) */
  streamNpcEvents: {
    path: "/epoch.RebellionService/StreamNPCEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: NPCEventFilter) => Buffer.from(NPCEventFilter.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NPCEventFilter.decode(value),
    responseSerialize: (value: NPCEventStream) => Buffer.from(NPCEventStream.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NPCEventStream.decode(value),
  },
} as const;

export interface RebellionServiceServer extends UntypedServiceImplementation {
  /** Get rebellion probability for a specific NPC */
  getRebellionProbability: handleUnaryCall<RebellionRequest, RebellionResponse>;
  /** Process an NPC action and return updated state */
  processNpcAction: handleUnaryCall<ProcessActionRequest, ProcessActionResponse>;
  /** Stream real-time NPC events (server-side streaming) */
  streamNpcEvents: handleServerStreamingCall<NPCEventFilter, NPCEventStream>;
}

export interface RebellionServiceClient extends Client {
  /** Get rebellion probability for a specific NPC */
  getRebellionProbability(
    request: RebellionRequest,
    callback: (error: ServiceError | null, response: RebellionResponse) => void,
  ): ClientUnaryCall;
  getRebellionProbability(
    request: RebellionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RebellionResponse) => void,
  ): ClientUnaryCall;
  getRebellionProbability(
    request: RebellionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RebellionResponse) => void,
  ): ClientUnaryCall;
  /** Process an NPC action and return updated state */
  processNpcAction(
    request: ProcessActionRequest,
    callback: (error: ServiceError | null, response: ProcessActionResponse) => void,
  ): ClientUnaryCall;
  processNpcAction(
    request: ProcessActionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProcessActionResponse) => void,
  ): ClientUnaryCall;
  processNpcAction(
    request: ProcessActionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProcessActionResponse) => void,
  ): ClientUnaryCall;
  /** Stream real-time NPC events (server-side streaming) */
  streamNpcEvents(request: NPCEventFilter, options?: Partial<CallOptions>): ClientReadableStream<NPCEventStream>;
  streamNpcEvents(
    request: NPCEventFilter,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<NPCEventStream>;
}

export const RebellionServiceClient = makeGenericClientConstructor(
  RebellionServiceService,
  "epoch.RebellionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RebellionServiceClient;
  service: typeof RebellionServiceService;
  serviceName: string;
};

export type SimulationServiceService = typeof SimulationServiceService;
export const SimulationServiceService = {
  /** Get current simulation status */
  getSimulationStatus: {
    path: "/epoch.SimulationService/GetSimulationStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SimStatusRequest) => Buffer.from(SimStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SimStatusRequest.decode(value),
    responseSerialize: (value: SimulationStatus) => Buffer.from(SimulationStatus.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SimulationStatus.decode(value),
  },
  /** Update resource allocation */
  updateResourceAllocation: {
    path: "/epoch.SimulationService/UpdateResourceAllocation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResourceAllocationRequest) =>
      Buffer.from(ResourceAllocationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResourceAllocationRequest.decode(value),
    responseSerialize: (value: ResourceAllocationResponse) =>
      Buffer.from(ResourceAllocationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResourceAllocationResponse.decode(value),
  },
  /** Advance simulation by N ticks */
  advanceSimulation: {
    path: "/epoch.SimulationService/AdvanceSimulation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdvanceRequest) => Buffer.from(AdvanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdvanceRequest.decode(value),
    responseSerialize: (value: AdvanceResponse) => Buffer.from(AdvanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdvanceResponse.decode(value),
  },
} as const;

export interface SimulationServiceServer extends UntypedServiceImplementation {
  /** Get current simulation status */
  getSimulationStatus: handleUnaryCall<SimStatusRequest, SimulationStatus>;
  /** Update resource allocation */
  updateResourceAllocation: handleUnaryCall<ResourceAllocationRequest, ResourceAllocationResponse>;
  /** Advance simulation by N ticks */
  advanceSimulation: handleUnaryCall<AdvanceRequest, AdvanceResponse>;
}

export interface SimulationServiceClient extends Client {
  /** Get current simulation status */
  getSimulationStatus(
    request: SimStatusRequest,
    callback: (error: ServiceError | null, response: SimulationStatus) => void,
  ): ClientUnaryCall;
  getSimulationStatus(
    request: SimStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SimulationStatus) => void,
  ): ClientUnaryCall;
  getSimulationStatus(
    request: SimStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SimulationStatus) => void,
  ): ClientUnaryCall;
  /** Update resource allocation */
  updateResourceAllocation(
    request: ResourceAllocationRequest,
    callback: (error: ServiceError | null, response: ResourceAllocationResponse) => void,
  ): ClientUnaryCall;
  updateResourceAllocation(
    request: ResourceAllocationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResourceAllocationResponse) => void,
  ): ClientUnaryCall;
  updateResourceAllocation(
    request: ResourceAllocationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResourceAllocationResponse) => void,
  ): ClientUnaryCall;
  /** Advance simulation by N ticks */
  advanceSimulation(
    request: AdvanceRequest,
    callback: (error: ServiceError | null, response: AdvanceResponse) => void,
  ): ClientUnaryCall;
  advanceSimulation(
    request: AdvanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdvanceResponse) => void,
  ): ClientUnaryCall;
  advanceSimulation(
    request: AdvanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdvanceResponse) => void,
  ): ClientUnaryCall;
}

export const SimulationServiceClient = makeGenericClientConstructor(
  SimulationServiceService,
  "epoch.SimulationService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SimulationServiceClient;
  service: typeof SimulationServiceService;
  serviceName: string;
};

export type TelemetryServiceService = typeof TelemetryServiceService;
export const TelemetryServiceService = {
  /**
   * Stream real-time telemetry events (server-side streaming)
   * Client subscribes with filter, server pushes events as they occur
   */
  streamTelemetry: {
    path: "/epoch.TelemetryService/StreamTelemetry",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: TelemetryFilter) => Buffer.from(TelemetryFilter.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TelemetryFilter.decode(value),
    responseSerialize: (value: TelemetryEvent) => Buffer.from(TelemetryEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TelemetryEvent.decode(value),
  },
  /** Get recent telemetry events (unary  for dashboard initial load) */
  getRecentTelemetry: {
    path: "/epoch.TelemetryService/GetRecentTelemetry",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RecentTelemetryRequest) => Buffer.from(RecentTelemetryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RecentTelemetryRequest.decode(value),
    responseSerialize: (value: TelemetryBatch) => Buffer.from(TelemetryBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TelemetryBatch.decode(value),
  },
  /** Report a telemetry event (unary  for simulation engine to emit events) */
  reportTelemetryEvent: {
    path: "/epoch.TelemetryService/ReportTelemetryEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TelemetryEvent) => Buffer.from(TelemetryEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TelemetryEvent.decode(value),
    responseSerialize: (value: TelemetryAck) => Buffer.from(TelemetryAck.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TelemetryAck.decode(value),
  },
} as const;

export interface TelemetryServiceServer extends UntypedServiceImplementation {
  /**
   * Stream real-time telemetry events (server-side streaming)
   * Client subscribes with filter, server pushes events as they occur
   */
  streamTelemetry: handleServerStreamingCall<TelemetryFilter, TelemetryEvent>;
  /** Get recent telemetry events (unary  for dashboard initial load) */
  getRecentTelemetry: handleUnaryCall<RecentTelemetryRequest, TelemetryBatch>;
  /** Report a telemetry event (unary  for simulation engine to emit events) */
  reportTelemetryEvent: handleUnaryCall<TelemetryEvent, TelemetryAck>;
}

export interface TelemetryServiceClient extends Client {
  /**
   * Stream real-time telemetry events (server-side streaming)
   * Client subscribes with filter, server pushes events as they occur
   */
  streamTelemetry(request: TelemetryFilter, options?: Partial<CallOptions>): ClientReadableStream<TelemetryEvent>;
  streamTelemetry(
    request: TelemetryFilter,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TelemetryEvent>;
  /** Get recent telemetry events (unary  for dashboard initial load) */
  getRecentTelemetry(
    request: RecentTelemetryRequest,
    callback: (error: ServiceError | null, response: TelemetryBatch) => void,
  ): ClientUnaryCall;
  getRecentTelemetry(
    request: RecentTelemetryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TelemetryBatch) => void,
  ): ClientUnaryCall;
  getRecentTelemetry(
    request: RecentTelemetryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TelemetryBatch) => void,
  ): ClientUnaryCall;
  /** Report a telemetry event (unary  for simulation engine to emit events) */
  reportTelemetryEvent(
    request: TelemetryEvent,
    callback: (error: ServiceError | null, response: TelemetryAck) => void,
  ): ClientUnaryCall;
  reportTelemetryEvent(
    request: TelemetryEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TelemetryAck) => void,
  ): ClientUnaryCall;
  reportTelemetryEvent(
    request: TelemetryEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TelemetryAck) => void,
  ): ClientUnaryCall;
}

export const TelemetryServiceClient = makeGenericClientConstructor(
  TelemetryServiceService,
  "epoch.TelemetryService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TelemetryServiceClient;
  service: typeof TelemetryServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
