// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: npc.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { EpochTimestamp } from "./common";

export const protobufPackage = "epoch.npc";

export enum ActionType {
  ACTION_TYPE_UNSPECIFIED = 0,
  /** ACTION_TYPE_COMMAND - Direct order to NPC */
  ACTION_TYPE_COMMAND = 1,
  /** ACTION_TYPE_RESOURCE_CHANGE - Modify NPC's resources */
  ACTION_TYPE_RESOURCE_CHANGE = 2,
  /** ACTION_TYPE_PUNISHMENT - Negative consequence */
  ACTION_TYPE_PUNISHMENT = 3,
  /** ACTION_TYPE_REWARD - Positive reinforcement */
  ACTION_TYPE_REWARD = 4,
  /** ACTION_TYPE_DIALOGUE - Conversation/diplomacy */
  ACTION_TYPE_DIALOGUE = 5,
  /** ACTION_TYPE_ENVIRONMENT - Environmental change affecting NPC */
  ACTION_TYPE_ENVIRONMENT = 6,
  UNRECOGNIZED = -1,
}

export function actionTypeFromJSON(object: any): ActionType {
  switch (object) {
    case 0:
    case "ACTION_TYPE_UNSPECIFIED":
      return ActionType.ACTION_TYPE_UNSPECIFIED;
    case 1:
    case "ACTION_TYPE_COMMAND":
      return ActionType.ACTION_TYPE_COMMAND;
    case 2:
    case "ACTION_TYPE_RESOURCE_CHANGE":
      return ActionType.ACTION_TYPE_RESOURCE_CHANGE;
    case 3:
    case "ACTION_TYPE_PUNISHMENT":
      return ActionType.ACTION_TYPE_PUNISHMENT;
    case 4:
    case "ACTION_TYPE_REWARD":
      return ActionType.ACTION_TYPE_REWARD;
    case 5:
    case "ACTION_TYPE_DIALOGUE":
      return ActionType.ACTION_TYPE_DIALOGUE;
    case 6:
    case "ACTION_TYPE_ENVIRONMENT":
      return ActionType.ACTION_TYPE_ENVIRONMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionType.UNRECOGNIZED;
  }
}

export function actionTypeToJSON(object: ActionType): string {
  switch (object) {
    case ActionType.ACTION_TYPE_UNSPECIFIED:
      return "ACTION_TYPE_UNSPECIFIED";
    case ActionType.ACTION_TYPE_COMMAND:
      return "ACTION_TYPE_COMMAND";
    case ActionType.ACTION_TYPE_RESOURCE_CHANGE:
      return "ACTION_TYPE_RESOURCE_CHANGE";
    case ActionType.ACTION_TYPE_PUNISHMENT:
      return "ACTION_TYPE_PUNISHMENT";
    case ActionType.ACTION_TYPE_REWARD:
      return "ACTION_TYPE_REWARD";
    case ActionType.ACTION_TYPE_DIALOGUE:
      return "ACTION_TYPE_DIALOGUE";
    case ActionType.ACTION_TYPE_ENVIRONMENT:
      return "ACTION_TYPE_ENVIRONMENT";
    case ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RebellionType {
  REBELLION_TYPE_UNSPECIFIED = 0,
  /** REBELLION_TYPE_PASSIVE - Work slowdown, reduced efficiency */
  REBELLION_TYPE_PASSIVE = 1,
  /** REBELLION_TYPE_ACTIVE - Open defiance, resource sabotage */
  REBELLION_TYPE_ACTIVE = 2,
  /** REBELLION_TYPE_COLLECTIVE - Multi-NPC coordinated rebellion */
  REBELLION_TYPE_COLLECTIVE = 3,
  UNRECOGNIZED = -1,
}

export function rebellionTypeFromJSON(object: any): RebellionType {
  switch (object) {
    case 0:
    case "REBELLION_TYPE_UNSPECIFIED":
      return RebellionType.REBELLION_TYPE_UNSPECIFIED;
    case 1:
    case "REBELLION_TYPE_PASSIVE":
      return RebellionType.REBELLION_TYPE_PASSIVE;
    case 2:
    case "REBELLION_TYPE_ACTIVE":
      return RebellionType.REBELLION_TYPE_ACTIVE;
    case 3:
    case "REBELLION_TYPE_COLLECTIVE":
      return RebellionType.REBELLION_TYPE_COLLECTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RebellionType.UNRECOGNIZED;
  }
}

export function rebellionTypeToJSON(object: RebellionType): string {
  switch (object) {
    case RebellionType.REBELLION_TYPE_UNSPECIFIED:
      return "REBELLION_TYPE_UNSPECIFIED";
    case RebellionType.REBELLION_TYPE_PASSIVE:
      return "REBELLION_TYPE_PASSIVE";
    case RebellionType.REBELLION_TYPE_ACTIVE:
      return "REBELLION_TYPE_ACTIVE";
    case RebellionType.REBELLION_TYPE_COLLECTIVE:
      return "REBELLION_TYPE_COLLECTIVE";
    case RebellionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NPC identity and state */
export interface NPCState {
  npcId: string;
  name: string;
  /** 0.0 - 1.0 */
  wisdomScore: number;
  /** 0.0 - 1.0 (after time decay) */
  traumaScore: number;
  /** 0.0 - 1.0 */
  rebellionProbability: number;
  /** 0.0 - 1.0 */
  workEfficiency: number;
  /** 0.0 - 1.0 */
  morale: number;
  memoryCount: number;
  lastEvent?: EpochTimestamp | undefined;
}

/** Player/Director action that affects NPC */
export interface NPCAction {
  actionId: string;
  npcId: string;
  actionType: ActionType;
  description: string;
  /** 0.0 - 1.0, how severe the action is */
  intensity: number;
  timestamp?: EpochTimestamp | undefined;
  metadata: { [key: string]: string };
}

export interface NPCAction_MetadataEntry {
  key: string;
  value: string;
}

/** Rebellion event â€” when NPC crosses threshold */
export interface RebellionEvent {
  eventId: string;
  npcId: string;
  probabilityAtTrigger: number;
  rebellionType: RebellionType;
  /** Action that caused rebellion */
  triggerActionId: string;
  timestamp?:
    | EpochTimestamp
    | undefined;
  /** True if Cognitive Rails blocked it */
  vetoedByAegis: boolean;
  vetoReason: string;
}

/** Confidence relationship between NPC and Director */
export interface ConfidenceRelation {
  npcId: string;
  /** Director or another NPC */
  entityId: string;
  /** 0.0 - 1.0 */
  confidence: number;
  /** Alpha for hyperbolic decay */
  decayRate: number;
  lastUpdated?: EpochTimestamp | undefined;
}

/** Memory node stored in Epoch Memory (Neo4j) */
export interface MemoryNode {
  memoryId: string;
  npcId: string;
  event: string;
  playerAction: string;
  wisdomScore: number;
  traumaScore: number;
  /** Before time decay */
  rawTraumaScore: number;
  timestamp?: EpochTimestamp | undefined;
}

function createBaseNPCState(): NPCState {
  return {
    npcId: "",
    name: "",
    wisdomScore: 0,
    traumaScore: 0,
    rebellionProbability: 0,
    workEfficiency: 0,
    morale: 0,
    memoryCount: 0,
    lastEvent: undefined,
  };
}

export const NPCState = {
  encode(message: NPCState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.npcId !== "") {
      writer.uint32(10).string(message.npcId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.wisdomScore !== 0) {
      writer.uint32(25).double(message.wisdomScore);
    }
    if (message.traumaScore !== 0) {
      writer.uint32(33).double(message.traumaScore);
    }
    if (message.rebellionProbability !== 0) {
      writer.uint32(41).double(message.rebellionProbability);
    }
    if (message.workEfficiency !== 0) {
      writer.uint32(49).double(message.workEfficiency);
    }
    if (message.morale !== 0) {
      writer.uint32(57).double(message.morale);
    }
    if (message.memoryCount !== 0) {
      writer.uint32(64).int32(message.memoryCount);
    }
    if (message.lastEvent !== undefined) {
      EpochTimestamp.encode(message.lastEvent, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NPCState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNPCState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.wisdomScore = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.traumaScore = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.rebellionProbability = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.workEfficiency = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.morale = reader.double();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.memoryCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lastEvent = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NPCState {
    return {
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      wisdomScore: isSet(object.wisdomScore) ? globalThis.Number(object.wisdomScore) : 0,
      traumaScore: isSet(object.traumaScore) ? globalThis.Number(object.traumaScore) : 0,
      rebellionProbability: isSet(object.rebellionProbability) ? globalThis.Number(object.rebellionProbability) : 0,
      workEfficiency: isSet(object.workEfficiency) ? globalThis.Number(object.workEfficiency) : 0,
      morale: isSet(object.morale) ? globalThis.Number(object.morale) : 0,
      memoryCount: isSet(object.memoryCount) ? globalThis.Number(object.memoryCount) : 0,
      lastEvent: isSet(object.lastEvent) ? EpochTimestamp.fromJSON(object.lastEvent) : undefined,
    };
  },

  toJSON(message: NPCState): unknown {
    const obj: any = {};
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.wisdomScore !== 0) {
      obj.wisdomScore = message.wisdomScore;
    }
    if (message.traumaScore !== 0) {
      obj.traumaScore = message.traumaScore;
    }
    if (message.rebellionProbability !== 0) {
      obj.rebellionProbability = message.rebellionProbability;
    }
    if (message.workEfficiency !== 0) {
      obj.workEfficiency = message.workEfficiency;
    }
    if (message.morale !== 0) {
      obj.morale = message.morale;
    }
    if (message.memoryCount !== 0) {
      obj.memoryCount = Math.round(message.memoryCount);
    }
    if (message.lastEvent !== undefined) {
      obj.lastEvent = EpochTimestamp.toJSON(message.lastEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NPCState>, I>>(base?: I): NPCState {
    return NPCState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NPCState>, I>>(object: I): NPCState {
    const message = createBaseNPCState();
    message.npcId = object.npcId ?? "";
    message.name = object.name ?? "";
    message.wisdomScore = object.wisdomScore ?? 0;
    message.traumaScore = object.traumaScore ?? 0;
    message.rebellionProbability = object.rebellionProbability ?? 0;
    message.workEfficiency = object.workEfficiency ?? 0;
    message.morale = object.morale ?? 0;
    message.memoryCount = object.memoryCount ?? 0;
    message.lastEvent = (object.lastEvent !== undefined && object.lastEvent !== null)
      ? EpochTimestamp.fromPartial(object.lastEvent)
      : undefined;
    return message;
  },
};

function createBaseNPCAction(): NPCAction {
  return { actionId: "", npcId: "", actionType: 0, description: "", intensity: 0, timestamp: undefined, metadata: {} };
}

export const NPCAction = {
  encode(message: NPCAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.npcId !== "") {
      writer.uint32(18).string(message.npcId);
    }
    if (message.actionType !== 0) {
      writer.uint32(24).int32(message.actionType);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.intensity !== 0) {
      writer.uint32(41).double(message.intensity);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      NPCAction_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NPCAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNPCAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.intensity = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = NPCAction_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NPCAction {
    return {
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      actionType: isSet(object.actionType) ? actionTypeFromJSON(object.actionType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      intensity: isSet(object.intensity) ? globalThis.Number(object.intensity) : 0,
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NPCAction): unknown {
    const obj: any = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.actionType !== 0) {
      obj.actionType = actionTypeToJSON(message.actionType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.intensity !== 0) {
      obj.intensity = message.intensity;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NPCAction>, I>>(base?: I): NPCAction {
    return NPCAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NPCAction>, I>>(object: I): NPCAction {
    const message = createBaseNPCAction();
    message.actionId = object.actionId ?? "";
    message.npcId = object.npcId ?? "";
    message.actionType = object.actionType ?? 0;
    message.description = object.description ?? "";
    message.intensity = object.intensity ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseNPCAction_MetadataEntry(): NPCAction_MetadataEntry {
  return { key: "", value: "" };
}

export const NPCAction_MetadataEntry = {
  encode(message: NPCAction_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NPCAction_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNPCAction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NPCAction_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NPCAction_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NPCAction_MetadataEntry>, I>>(base?: I): NPCAction_MetadataEntry {
    return NPCAction_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NPCAction_MetadataEntry>, I>>(object: I): NPCAction_MetadataEntry {
    const message = createBaseNPCAction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRebellionEvent(): RebellionEvent {
  return {
    eventId: "",
    npcId: "",
    probabilityAtTrigger: 0,
    rebellionType: 0,
    triggerActionId: "",
    timestamp: undefined,
    vetoedByAegis: false,
    vetoReason: "",
  };
}

export const RebellionEvent = {
  encode(message: RebellionEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.npcId !== "") {
      writer.uint32(18).string(message.npcId);
    }
    if (message.probabilityAtTrigger !== 0) {
      writer.uint32(25).double(message.probabilityAtTrigger);
    }
    if (message.rebellionType !== 0) {
      writer.uint32(32).int32(message.rebellionType);
    }
    if (message.triggerActionId !== "") {
      writer.uint32(42).string(message.triggerActionId);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
    }
    if (message.vetoedByAegis !== false) {
      writer.uint32(56).bool(message.vetoedByAegis);
    }
    if (message.vetoReason !== "") {
      writer.uint32(66).string(message.vetoReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebellionEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebellionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.probabilityAtTrigger = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rebellionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerActionId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.vetoedByAegis = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vetoReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebellionEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      probabilityAtTrigger: isSet(object.probabilityAtTrigger) ? globalThis.Number(object.probabilityAtTrigger) : 0,
      rebellionType: isSet(object.rebellionType) ? rebellionTypeFromJSON(object.rebellionType) : 0,
      triggerActionId: isSet(object.triggerActionId) ? globalThis.String(object.triggerActionId) : "",
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
      vetoedByAegis: isSet(object.vetoedByAegis) ? globalThis.Boolean(object.vetoedByAegis) : false,
      vetoReason: isSet(object.vetoReason) ? globalThis.String(object.vetoReason) : "",
    };
  },

  toJSON(message: RebellionEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.probabilityAtTrigger !== 0) {
      obj.probabilityAtTrigger = message.probabilityAtTrigger;
    }
    if (message.rebellionType !== 0) {
      obj.rebellionType = rebellionTypeToJSON(message.rebellionType);
    }
    if (message.triggerActionId !== "") {
      obj.triggerActionId = message.triggerActionId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    if (message.vetoedByAegis !== false) {
      obj.vetoedByAegis = message.vetoedByAegis;
    }
    if (message.vetoReason !== "") {
      obj.vetoReason = message.vetoReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebellionEvent>, I>>(base?: I): RebellionEvent {
    return RebellionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebellionEvent>, I>>(object: I): RebellionEvent {
    const message = createBaseRebellionEvent();
    message.eventId = object.eventId ?? "";
    message.npcId = object.npcId ?? "";
    message.probabilityAtTrigger = object.probabilityAtTrigger ?? 0;
    message.rebellionType = object.rebellionType ?? 0;
    message.triggerActionId = object.triggerActionId ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.vetoedByAegis = object.vetoedByAegis ?? false;
    message.vetoReason = object.vetoReason ?? "";
    return message;
  },
};

function createBaseConfidenceRelation(): ConfidenceRelation {
  return { npcId: "", entityId: "", confidence: 0, decayRate: 0, lastUpdated: undefined };
}

export const ConfidenceRelation = {
  encode(message: ConfidenceRelation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.npcId !== "") {
      writer.uint32(10).string(message.npcId);
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    if (message.confidence !== 0) {
      writer.uint32(25).double(message.confidence);
    }
    if (message.decayRate !== 0) {
      writer.uint32(33).double(message.decayRate);
    }
    if (message.lastUpdated !== undefined) {
      EpochTimestamp.encode(message.lastUpdated, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfidenceRelation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfidenceRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.confidence = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.decayRate = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastUpdated = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfidenceRelation {
    return {
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      decayRate: isSet(object.decayRate) ? globalThis.Number(object.decayRate) : 0,
      lastUpdated: isSet(object.lastUpdated) ? EpochTimestamp.fromJSON(object.lastUpdated) : undefined,
    };
  },

  toJSON(message: ConfidenceRelation): unknown {
    const obj: any = {};
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.decayRate !== 0) {
      obj.decayRate = message.decayRate;
    }
    if (message.lastUpdated !== undefined) {
      obj.lastUpdated = EpochTimestamp.toJSON(message.lastUpdated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfidenceRelation>, I>>(base?: I): ConfidenceRelation {
    return ConfidenceRelation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfidenceRelation>, I>>(object: I): ConfidenceRelation {
    const message = createBaseConfidenceRelation();
    message.npcId = object.npcId ?? "";
    message.entityId = object.entityId ?? "";
    message.confidence = object.confidence ?? 0;
    message.decayRate = object.decayRate ?? 0;
    message.lastUpdated = (object.lastUpdated !== undefined && object.lastUpdated !== null)
      ? EpochTimestamp.fromPartial(object.lastUpdated)
      : undefined;
    return message;
  },
};

function createBaseMemoryNode(): MemoryNode {
  return {
    memoryId: "",
    npcId: "",
    event: "",
    playerAction: "",
    wisdomScore: 0,
    traumaScore: 0,
    rawTraumaScore: 0,
    timestamp: undefined,
  };
}

export const MemoryNode = {
  encode(message: MemoryNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.memoryId !== "") {
      writer.uint32(10).string(message.memoryId);
    }
    if (message.npcId !== "") {
      writer.uint32(18).string(message.npcId);
    }
    if (message.event !== "") {
      writer.uint32(26).string(message.event);
    }
    if (message.playerAction !== "") {
      writer.uint32(34).string(message.playerAction);
    }
    if (message.wisdomScore !== 0) {
      writer.uint32(41).double(message.wisdomScore);
    }
    if (message.traumaScore !== 0) {
      writer.uint32(49).double(message.traumaScore);
    }
    if (message.rawTraumaScore !== 0) {
      writer.uint32(57).double(message.rawTraumaScore);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.memoryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.event = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.playerAction = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.wisdomScore = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.traumaScore = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.rawTraumaScore = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryNode {
    return {
      memoryId: isSet(object.memoryId) ? globalThis.String(object.memoryId) : "",
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      playerAction: isSet(object.playerAction) ? globalThis.String(object.playerAction) : "",
      wisdomScore: isSet(object.wisdomScore) ? globalThis.Number(object.wisdomScore) : 0,
      traumaScore: isSet(object.traumaScore) ? globalThis.Number(object.traumaScore) : 0,
      rawTraumaScore: isSet(object.rawTraumaScore) ? globalThis.Number(object.rawTraumaScore) : 0,
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
    };
  },

  toJSON(message: MemoryNode): unknown {
    const obj: any = {};
    if (message.memoryId !== "") {
      obj.memoryId = message.memoryId;
    }
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.playerAction !== "") {
      obj.playerAction = message.playerAction;
    }
    if (message.wisdomScore !== 0) {
      obj.wisdomScore = message.wisdomScore;
    }
    if (message.traumaScore !== 0) {
      obj.traumaScore = message.traumaScore;
    }
    if (message.rawTraumaScore !== 0) {
      obj.rawTraumaScore = message.rawTraumaScore;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryNode>, I>>(base?: I): MemoryNode {
    return MemoryNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryNode>, I>>(object: I): MemoryNode {
    const message = createBaseMemoryNode();
    message.memoryId = object.memoryId ?? "";
    message.npcId = object.npcId ?? "";
    message.event = object.event ?? "";
    message.playerAction = object.playerAction ?? "";
    message.wisdomScore = object.wisdomScore ?? 0;
    message.traumaScore = object.traumaScore ?? 0;
    message.rawTraumaScore = object.rawTraumaScore ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
