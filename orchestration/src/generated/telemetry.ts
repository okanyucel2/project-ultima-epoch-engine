// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: telemetry.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { EpochTimestamp } from "./common";
import { NPCState } from "./npc";

export const protobufPackage = "epoch.telemetry";

/**
 * ---------------------------------------------------------------------------
 * Severity — determines dashboard visual urgency + AEGIS response tier
 * ---------------------------------------------------------------------------
 */
export enum TelemetrySeverity {
  TELEMETRY_SEVERITY_UNSPECIFIED = 0,
  /** TELEMETRY_SEVERITY_INFO - Normal telemetry pulse */
  TELEMETRY_SEVERITY_INFO = 1,
  /** TELEMETRY_SEVERITY_WARNING - Elevated concern, monitor closely */
  TELEMETRY_SEVERITY_WARNING = 2,
  /** TELEMETRY_SEVERITY_CRITICAL - Immediate AEGIS attention required */
  TELEMETRY_SEVERITY_CRITICAL = 3,
  /** TELEMETRY_SEVERITY_CATASTROPHIC - System-wide impact, NPC unrecoverable */
  TELEMETRY_SEVERITY_CATASTROPHIC = 4,
  UNRECOGNIZED = -1,
}

export function telemetrySeverityFromJSON(object: any): TelemetrySeverity {
  switch (object) {
    case 0:
    case "TELEMETRY_SEVERITY_UNSPECIFIED":
      return TelemetrySeverity.TELEMETRY_SEVERITY_UNSPECIFIED;
    case 1:
    case "TELEMETRY_SEVERITY_INFO":
      return TelemetrySeverity.TELEMETRY_SEVERITY_INFO;
    case 2:
    case "TELEMETRY_SEVERITY_WARNING":
      return TelemetrySeverity.TELEMETRY_SEVERITY_WARNING;
    case 3:
    case "TELEMETRY_SEVERITY_CRITICAL":
      return TelemetrySeverity.TELEMETRY_SEVERITY_CRITICAL;
    case 4:
    case "TELEMETRY_SEVERITY_CATASTROPHIC":
      return TelemetrySeverity.TELEMETRY_SEVERITY_CATASTROPHIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TelemetrySeverity.UNRECOGNIZED;
  }
}

export function telemetrySeverityToJSON(object: TelemetrySeverity): string {
  switch (object) {
    case TelemetrySeverity.TELEMETRY_SEVERITY_UNSPECIFIED:
      return "TELEMETRY_SEVERITY_UNSPECIFIED";
    case TelemetrySeverity.TELEMETRY_SEVERITY_INFO:
      return "TELEMETRY_SEVERITY_INFO";
    case TelemetrySeverity.TELEMETRY_SEVERITY_WARNING:
      return "TELEMETRY_SEVERITY_WARNING";
    case TelemetrySeverity.TELEMETRY_SEVERITY_CRITICAL:
      return "TELEMETRY_SEVERITY_CRITICAL";
    case TelemetrySeverity.TELEMETRY_SEVERITY_CATASTROPHIC:
      return "TELEMETRY_SEVERITY_CATASTROPHIC";
    case TelemetrySeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ---------------------------------------------------------------------------
 * Mental Breakdown Types — The Alters model (transient, recoverable)
 * ---------------------------------------------------------------------------
 */
export enum MentalBreakdownType {
  MENTAL_BREAKDOWN_UNSPECIFIED = 0,
  /** MENTAL_BREAKDOWN_STRESS_SPIKE - Acute pressure overload */
  MENTAL_BREAKDOWN_STRESS_SPIKE = 1,
  /** MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE - Cognitive split / dissociation */
  MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE = 2,
  /** MENTAL_BREAKDOWN_IDENTITY_CRISIS - NPC questions purpose/role */
  MENTAL_BREAKDOWN_IDENTITY_CRISIS = 3,
  /** MENTAL_BREAKDOWN_PARANOIA_ONSET - Distrust of director/peers */
  MENTAL_BREAKDOWN_PARANOIA_ONSET = 4,
  /** MENTAL_BREAKDOWN_DISSOCIATION - Emotional detachment from reality */
  MENTAL_BREAKDOWN_DISSOCIATION = 5,
  /** MENTAL_BREAKDOWN_RAGE_EPISODE - Uncontrolled aggression burst */
  MENTAL_BREAKDOWN_RAGE_EPISODE = 6,
  UNRECOGNIZED = -1,
}

export function mentalBreakdownTypeFromJSON(object: any): MentalBreakdownType {
  switch (object) {
    case 0:
    case "MENTAL_BREAKDOWN_UNSPECIFIED":
      return MentalBreakdownType.MENTAL_BREAKDOWN_UNSPECIFIED;
    case 1:
    case "MENTAL_BREAKDOWN_STRESS_SPIKE":
      return MentalBreakdownType.MENTAL_BREAKDOWN_STRESS_SPIKE;
    case 2:
    case "MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE":
      return MentalBreakdownType.MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE;
    case 3:
    case "MENTAL_BREAKDOWN_IDENTITY_CRISIS":
      return MentalBreakdownType.MENTAL_BREAKDOWN_IDENTITY_CRISIS;
    case 4:
    case "MENTAL_BREAKDOWN_PARANOIA_ONSET":
      return MentalBreakdownType.MENTAL_BREAKDOWN_PARANOIA_ONSET;
    case 5:
    case "MENTAL_BREAKDOWN_DISSOCIATION":
      return MentalBreakdownType.MENTAL_BREAKDOWN_DISSOCIATION;
    case 6:
    case "MENTAL_BREAKDOWN_RAGE_EPISODE":
      return MentalBreakdownType.MENTAL_BREAKDOWN_RAGE_EPISODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MentalBreakdownType.UNRECOGNIZED;
  }
}

export function mentalBreakdownTypeToJSON(object: MentalBreakdownType): string {
  switch (object) {
    case MentalBreakdownType.MENTAL_BREAKDOWN_UNSPECIFIED:
      return "MENTAL_BREAKDOWN_UNSPECIFIED";
    case MentalBreakdownType.MENTAL_BREAKDOWN_STRESS_SPIKE:
      return "MENTAL_BREAKDOWN_STRESS_SPIKE";
    case MentalBreakdownType.MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE:
      return "MENTAL_BREAKDOWN_PSYCHOLOGICAL_FRACTURE";
    case MentalBreakdownType.MENTAL_BREAKDOWN_IDENTITY_CRISIS:
      return "MENTAL_BREAKDOWN_IDENTITY_CRISIS";
    case MentalBreakdownType.MENTAL_BREAKDOWN_PARANOIA_ONSET:
      return "MENTAL_BREAKDOWN_PARANOIA_ONSET";
    case MentalBreakdownType.MENTAL_BREAKDOWN_DISSOCIATION:
      return "MENTAL_BREAKDOWN_DISSOCIATION";
    case MentalBreakdownType.MENTAL_BREAKDOWN_RAGE_EPISODE:
      return "MENTAL_BREAKDOWN_RAGE_EPISODE";
    case MentalBreakdownType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ---------------------------------------------------------------------------
 * Permanent Trauma Types — Battle Brothers model (irreversible)
 * ---------------------------------------------------------------------------
 */
export enum PermanentTraumaType {
  PERMANENT_TRAUMA_UNSPECIFIED = 0,
  /** PERMANENT_TRAUMA_LIMB_LOSS - Physical injury → -work_efficiency */
  PERMANENT_TRAUMA_LIMB_LOSS = 1,
  /** PERMANENT_TRAUMA_MORALE_COLLAPSE - Irreversible morale floor */
  PERMANENT_TRAUMA_MORALE_COLLAPSE = 2,
  /** PERMANENT_TRAUMA_PTSD - Flashback triggers in similar contexts */
  PERMANENT_TRAUMA_PTSD = 3,
  /** PERMANENT_TRAUMA_SURVIVORS_GUILT - After witnessing comrade death */
  PERMANENT_TRAUMA_SURVIVORS_GUILT = 4,
  /** PERMANENT_TRAUMA_PHOBIA - Fear of specific condition (mines, combat) */
  PERMANENT_TRAUMA_PHOBIA = 5,
  /** PERMANENT_TRAUMA_BRAIN_DAMAGE - Cognitive impairment → -wisdom_score */
  PERMANENT_TRAUMA_BRAIN_DAMAGE = 6,
  UNRECOGNIZED = -1,
}

export function permanentTraumaTypeFromJSON(object: any): PermanentTraumaType {
  switch (object) {
    case 0:
    case "PERMANENT_TRAUMA_UNSPECIFIED":
      return PermanentTraumaType.PERMANENT_TRAUMA_UNSPECIFIED;
    case 1:
    case "PERMANENT_TRAUMA_LIMB_LOSS":
      return PermanentTraumaType.PERMANENT_TRAUMA_LIMB_LOSS;
    case 2:
    case "PERMANENT_TRAUMA_MORALE_COLLAPSE":
      return PermanentTraumaType.PERMANENT_TRAUMA_MORALE_COLLAPSE;
    case 3:
    case "PERMANENT_TRAUMA_PTSD":
      return PermanentTraumaType.PERMANENT_TRAUMA_PTSD;
    case 4:
    case "PERMANENT_TRAUMA_SURVIVORS_GUILT":
      return PermanentTraumaType.PERMANENT_TRAUMA_SURVIVORS_GUILT;
    case 5:
    case "PERMANENT_TRAUMA_PHOBIA":
      return PermanentTraumaType.PERMANENT_TRAUMA_PHOBIA;
    case 6:
    case "PERMANENT_TRAUMA_BRAIN_DAMAGE":
      return PermanentTraumaType.PERMANENT_TRAUMA_BRAIN_DAMAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermanentTraumaType.UNRECOGNIZED;
  }
}

export function permanentTraumaTypeToJSON(object: PermanentTraumaType): string {
  switch (object) {
    case PermanentTraumaType.PERMANENT_TRAUMA_UNSPECIFIED:
      return "PERMANENT_TRAUMA_UNSPECIFIED";
    case PermanentTraumaType.PERMANENT_TRAUMA_LIMB_LOSS:
      return "PERMANENT_TRAUMA_LIMB_LOSS";
    case PermanentTraumaType.PERMANENT_TRAUMA_MORALE_COLLAPSE:
      return "PERMANENT_TRAUMA_MORALE_COLLAPSE";
    case PermanentTraumaType.PERMANENT_TRAUMA_PTSD:
      return "PERMANENT_TRAUMA_PTSD";
    case PermanentTraumaType.PERMANENT_TRAUMA_SURVIVORS_GUILT:
      return "PERMANENT_TRAUMA_SURVIVORS_GUILT";
    case PermanentTraumaType.PERMANENT_TRAUMA_PHOBIA:
      return "PERMANENT_TRAUMA_PHOBIA";
    case PermanentTraumaType.PERMANENT_TRAUMA_BRAIN_DAMAGE:
      return "PERMANENT_TRAUMA_BRAIN_DAMAGE";
    case PermanentTraumaType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ---------------------------------------------------------------------------
 * Mental Breakdown Event — transient psychological crisis
 * ---------------------------------------------------------------------------
 */
export interface MentalBreakdownEvent {
  type: MentalBreakdownType;
  /** 0.0 - 1.0 severity within type */
  intensity: number;
  /** Stress level before event */
  stressBefore: number;
  /** Stress level after event */
  stressAfter: number;
  /** What caused it (action_id, env event, etc.) */
  triggerContext: string;
  /** True if NPC recovered (set later via update) */
  resolved: boolean;
  /** Estimated chance of natural recovery */
  recoveryProbability: number;
}

/**
 * ---------------------------------------------------------------------------
 * Permanent Trauma Event — irreversible state change
 * ---------------------------------------------------------------------------
 */
export interface PermanentTraumaEvent {
  type: PermanentTraumaType;
  /** 0.0 - 1.0 how severe */
  severity: number;
  /** Which NPC stat is permanently reduced */
  affectedAttribute: string;
  /** How much the stat is reduced (absolute) */
  attributeReduction: number;
  /** What caused it */
  triggerContext: string;
  /** Only for PHOBIA type: what they fear */
  phobiaTarget: string;
  inflictedAt?: EpochTimestamp | undefined;
}

/**
 * ---------------------------------------------------------------------------
 * Telemetry Event — the unified event wrapper
 * ---------------------------------------------------------------------------
 */
export interface TelemetryEvent {
  /** Unique telemetry event ID */
  eventId: string;
  /** Affected NPC */
  npcId: string;
  /** Visual urgency tier */
  severity: TelemetrySeverity;
  /** Millisecond-precision emission time */
  timestamp?: EpochTimestamp | undefined;
  mentalBreakdown?: MentalBreakdownEvent | undefined;
  permanentTrauma?: PermanentTraumaEvent | undefined;
  stateChange?:
    | StateChangeEvent
    | undefined;
  /** Post-event NPC snapshot (optional — included for dashboard rendering) */
  npcSnapshot?: NPCState | undefined;
}

/**
 * ---------------------------------------------------------------------------
 * State Change Event — general NPC stat delta (non-trauma, non-breakdown)
 * ---------------------------------------------------------------------------
 */
export interface StateChangeEvent {
  /** "morale", "work_efficiency", "trauma_score", etc. */
  attribute: string;
  oldValue: number;
  newValue: number;
  /** Human-readable cause */
  cause: string;
}

/**
 * ---------------------------------------------------------------------------
 * Telemetry Batch — for bulk delivery (batch tick results)
 * ---------------------------------------------------------------------------
 */
export interface TelemetryBatch {
  events: TelemetryEvent[];
  tickNumber: number;
  batchTimestamp?: EpochTimestamp | undefined;
}

/**
 * ---------------------------------------------------------------------------
 * Telemetry Filter — for stream subscription
 * ---------------------------------------------------------------------------
 */
export interface TelemetryFilter {
  /** Empty = all NPCs */
  npcIds: string[];
  /** Only events >= this severity */
  minSeverity: TelemetrySeverity;
  /** Include general stat deltas */
  includeStateChanges: boolean;
  /** Include The Alters events */
  includeMentalBreakdowns: boolean;
  /** Include Battle Brothers events */
  includePermanentTraumas: boolean;
}

function createBaseMentalBreakdownEvent(): MentalBreakdownEvent {
  return {
    type: 0,
    intensity: 0,
    stressBefore: 0,
    stressAfter: 0,
    triggerContext: "",
    resolved: false,
    recoveryProbability: 0,
  };
}

export const MentalBreakdownEvent = {
  encode(message: MentalBreakdownEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.intensity !== 0) {
      writer.uint32(17).double(message.intensity);
    }
    if (message.stressBefore !== 0) {
      writer.uint32(25).double(message.stressBefore);
    }
    if (message.stressAfter !== 0) {
      writer.uint32(33).double(message.stressAfter);
    }
    if (message.triggerContext !== "") {
      writer.uint32(42).string(message.triggerContext);
    }
    if (message.resolved !== false) {
      writer.uint32(48).bool(message.resolved);
    }
    if (message.recoveryProbability !== 0) {
      writer.uint32(57).double(message.recoveryProbability);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MentalBreakdownEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMentalBreakdownEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.intensity = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.stressBefore = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.stressAfter = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerContext = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.resolved = reader.bool();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.recoveryProbability = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MentalBreakdownEvent {
    return {
      type: isSet(object.type) ? mentalBreakdownTypeFromJSON(object.type) : 0,
      intensity: isSet(object.intensity) ? globalThis.Number(object.intensity) : 0,
      stressBefore: isSet(object.stressBefore) ? globalThis.Number(object.stressBefore) : 0,
      stressAfter: isSet(object.stressAfter) ? globalThis.Number(object.stressAfter) : 0,
      triggerContext: isSet(object.triggerContext) ? globalThis.String(object.triggerContext) : "",
      resolved: isSet(object.resolved) ? globalThis.Boolean(object.resolved) : false,
      recoveryProbability: isSet(object.recoveryProbability) ? globalThis.Number(object.recoveryProbability) : 0,
    };
  },

  toJSON(message: MentalBreakdownEvent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = mentalBreakdownTypeToJSON(message.type);
    }
    if (message.intensity !== 0) {
      obj.intensity = message.intensity;
    }
    if (message.stressBefore !== 0) {
      obj.stressBefore = message.stressBefore;
    }
    if (message.stressAfter !== 0) {
      obj.stressAfter = message.stressAfter;
    }
    if (message.triggerContext !== "") {
      obj.triggerContext = message.triggerContext;
    }
    if (message.resolved !== false) {
      obj.resolved = message.resolved;
    }
    if (message.recoveryProbability !== 0) {
      obj.recoveryProbability = message.recoveryProbability;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MentalBreakdownEvent>, I>>(base?: I): MentalBreakdownEvent {
    return MentalBreakdownEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MentalBreakdownEvent>, I>>(object: I): MentalBreakdownEvent {
    const message = createBaseMentalBreakdownEvent();
    message.type = object.type ?? 0;
    message.intensity = object.intensity ?? 0;
    message.stressBefore = object.stressBefore ?? 0;
    message.stressAfter = object.stressAfter ?? 0;
    message.triggerContext = object.triggerContext ?? "";
    message.resolved = object.resolved ?? false;
    message.recoveryProbability = object.recoveryProbability ?? 0;
    return message;
  },
};

function createBasePermanentTraumaEvent(): PermanentTraumaEvent {
  return {
    type: 0,
    severity: 0,
    affectedAttribute: "",
    attributeReduction: 0,
    triggerContext: "",
    phobiaTarget: "",
    inflictedAt: undefined,
  };
}

export const PermanentTraumaEvent = {
  encode(message: PermanentTraumaEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.severity !== 0) {
      writer.uint32(17).double(message.severity);
    }
    if (message.affectedAttribute !== "") {
      writer.uint32(26).string(message.affectedAttribute);
    }
    if (message.attributeReduction !== 0) {
      writer.uint32(33).double(message.attributeReduction);
    }
    if (message.triggerContext !== "") {
      writer.uint32(42).string(message.triggerContext);
    }
    if (message.phobiaTarget !== "") {
      writer.uint32(50).string(message.phobiaTarget);
    }
    if (message.inflictedAt !== undefined) {
      EpochTimestamp.encode(message.inflictedAt, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermanentTraumaEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermanentTraumaEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.severity = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.affectedAttribute = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.attributeReduction = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerContext = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.phobiaTarget = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.inflictedAt = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermanentTraumaEvent {
    return {
      type: isSet(object.type) ? permanentTraumaTypeFromJSON(object.type) : 0,
      severity: isSet(object.severity) ? globalThis.Number(object.severity) : 0,
      affectedAttribute: isSet(object.affectedAttribute) ? globalThis.String(object.affectedAttribute) : "",
      attributeReduction: isSet(object.attributeReduction) ? globalThis.Number(object.attributeReduction) : 0,
      triggerContext: isSet(object.triggerContext) ? globalThis.String(object.triggerContext) : "",
      phobiaTarget: isSet(object.phobiaTarget) ? globalThis.String(object.phobiaTarget) : "",
      inflictedAt: isSet(object.inflictedAt) ? EpochTimestamp.fromJSON(object.inflictedAt) : undefined,
    };
  },

  toJSON(message: PermanentTraumaEvent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = permanentTraumaTypeToJSON(message.type);
    }
    if (message.severity !== 0) {
      obj.severity = message.severity;
    }
    if (message.affectedAttribute !== "") {
      obj.affectedAttribute = message.affectedAttribute;
    }
    if (message.attributeReduction !== 0) {
      obj.attributeReduction = message.attributeReduction;
    }
    if (message.triggerContext !== "") {
      obj.triggerContext = message.triggerContext;
    }
    if (message.phobiaTarget !== "") {
      obj.phobiaTarget = message.phobiaTarget;
    }
    if (message.inflictedAt !== undefined) {
      obj.inflictedAt = EpochTimestamp.toJSON(message.inflictedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermanentTraumaEvent>, I>>(base?: I): PermanentTraumaEvent {
    return PermanentTraumaEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermanentTraumaEvent>, I>>(object: I): PermanentTraumaEvent {
    const message = createBasePermanentTraumaEvent();
    message.type = object.type ?? 0;
    message.severity = object.severity ?? 0;
    message.affectedAttribute = object.affectedAttribute ?? "";
    message.attributeReduction = object.attributeReduction ?? 0;
    message.triggerContext = object.triggerContext ?? "";
    message.phobiaTarget = object.phobiaTarget ?? "";
    message.inflictedAt = (object.inflictedAt !== undefined && object.inflictedAt !== null)
      ? EpochTimestamp.fromPartial(object.inflictedAt)
      : undefined;
    return message;
  },
};

function createBaseTelemetryEvent(): TelemetryEvent {
  return {
    eventId: "",
    npcId: "",
    severity: 0,
    timestamp: undefined,
    mentalBreakdown: undefined,
    permanentTrauma: undefined,
    stateChange: undefined,
    npcSnapshot: undefined,
  };
}

export const TelemetryEvent = {
  encode(message: TelemetryEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.npcId !== "") {
      writer.uint32(18).string(message.npcId);
    }
    if (message.severity !== 0) {
      writer.uint32(24).int32(message.severity);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(34).fork()).ldelim();
    }
    if (message.mentalBreakdown !== undefined) {
      MentalBreakdownEvent.encode(message.mentalBreakdown, writer.uint32(82).fork()).ldelim();
    }
    if (message.permanentTrauma !== undefined) {
      PermanentTraumaEvent.encode(message.permanentTrauma, writer.uint32(90).fork()).ldelim();
    }
    if (message.stateChange !== undefined) {
      StateChangeEvent.encode(message.stateChange, writer.uint32(98).fork()).ldelim();
    }
    if (message.npcSnapshot !== undefined) {
      NPCState.encode(message.npcSnapshot, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TelemetryEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mentalBreakdown = MentalBreakdownEvent.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.permanentTrauma = PermanentTraumaEvent.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.stateChange = StateChangeEvent.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.npcSnapshot = NPCState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      npcId: isSet(object.npcId) ? globalThis.String(object.npcId) : "",
      severity: isSet(object.severity) ? telemetrySeverityFromJSON(object.severity) : 0,
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
      mentalBreakdown: isSet(object.mentalBreakdown)
        ? MentalBreakdownEvent.fromJSON(object.mentalBreakdown)
        : undefined,
      permanentTrauma: isSet(object.permanentTrauma)
        ? PermanentTraumaEvent.fromJSON(object.permanentTrauma)
        : undefined,
      stateChange: isSet(object.stateChange) ? StateChangeEvent.fromJSON(object.stateChange) : undefined,
      npcSnapshot: isSet(object.npcSnapshot) ? NPCState.fromJSON(object.npcSnapshot) : undefined,
    };
  },

  toJSON(message: TelemetryEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.npcId !== "") {
      obj.npcId = message.npcId;
    }
    if (message.severity !== 0) {
      obj.severity = telemetrySeverityToJSON(message.severity);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    if (message.mentalBreakdown !== undefined) {
      obj.mentalBreakdown = MentalBreakdownEvent.toJSON(message.mentalBreakdown);
    }
    if (message.permanentTrauma !== undefined) {
      obj.permanentTrauma = PermanentTraumaEvent.toJSON(message.permanentTrauma);
    }
    if (message.stateChange !== undefined) {
      obj.stateChange = StateChangeEvent.toJSON(message.stateChange);
    }
    if (message.npcSnapshot !== undefined) {
      obj.npcSnapshot = NPCState.toJSON(message.npcSnapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryEvent>, I>>(base?: I): TelemetryEvent {
    return TelemetryEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryEvent>, I>>(object: I): TelemetryEvent {
    const message = createBaseTelemetryEvent();
    message.eventId = object.eventId ?? "";
    message.npcId = object.npcId ?? "";
    message.severity = object.severity ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.mentalBreakdown = (object.mentalBreakdown !== undefined && object.mentalBreakdown !== null)
      ? MentalBreakdownEvent.fromPartial(object.mentalBreakdown)
      : undefined;
    message.permanentTrauma = (object.permanentTrauma !== undefined && object.permanentTrauma !== null)
      ? PermanentTraumaEvent.fromPartial(object.permanentTrauma)
      : undefined;
    message.stateChange = (object.stateChange !== undefined && object.stateChange !== null)
      ? StateChangeEvent.fromPartial(object.stateChange)
      : undefined;
    message.npcSnapshot = (object.npcSnapshot !== undefined && object.npcSnapshot !== null)
      ? NPCState.fromPartial(object.npcSnapshot)
      : undefined;
    return message;
  },
};

function createBaseStateChangeEvent(): StateChangeEvent {
  return { attribute: "", oldValue: 0, newValue: 0, cause: "" };
}

export const StateChangeEvent = {
  encode(message: StateChangeEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    if (message.oldValue !== 0) {
      writer.uint32(17).double(message.oldValue);
    }
    if (message.newValue !== 0) {
      writer.uint32(25).double(message.newValue);
    }
    if (message.cause !== "") {
      writer.uint32(34).string(message.cause);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateChangeEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateChangeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.oldValue = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.newValue = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cause = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateChangeEvent {
    return {
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      oldValue: isSet(object.oldValue) ? globalThis.Number(object.oldValue) : 0,
      newValue: isSet(object.newValue) ? globalThis.Number(object.newValue) : 0,
      cause: isSet(object.cause) ? globalThis.String(object.cause) : "",
    };
  },

  toJSON(message: StateChangeEvent): unknown {
    const obj: any = {};
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.oldValue !== 0) {
      obj.oldValue = message.oldValue;
    }
    if (message.newValue !== 0) {
      obj.newValue = message.newValue;
    }
    if (message.cause !== "") {
      obj.cause = message.cause;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateChangeEvent>, I>>(base?: I): StateChangeEvent {
    return StateChangeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateChangeEvent>, I>>(object: I): StateChangeEvent {
    const message = createBaseStateChangeEvent();
    message.attribute = object.attribute ?? "";
    message.oldValue = object.oldValue ?? 0;
    message.newValue = object.newValue ?? 0;
    message.cause = object.cause ?? "";
    return message;
  },
};

function createBaseTelemetryBatch(): TelemetryBatch {
  return { events: [], tickNumber: 0, batchTimestamp: undefined };
}

export const TelemetryBatch = {
  encode(message: TelemetryBatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      TelemetryEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.tickNumber !== 0) {
      writer.uint32(16).int64(message.tickNumber);
    }
    if (message.batchTimestamp !== undefined) {
      EpochTimestamp.encode(message.batchTimestamp, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TelemetryBatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(TelemetryEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tickNumber = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.batchTimestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryBatch {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => TelemetryEvent.fromJSON(e)) : [],
      tickNumber: isSet(object.tickNumber) ? globalThis.Number(object.tickNumber) : 0,
      batchTimestamp: isSet(object.batchTimestamp) ? EpochTimestamp.fromJSON(object.batchTimestamp) : undefined,
    };
  },

  toJSON(message: TelemetryBatch): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => TelemetryEvent.toJSON(e));
    }
    if (message.tickNumber !== 0) {
      obj.tickNumber = Math.round(message.tickNumber);
    }
    if (message.batchTimestamp !== undefined) {
      obj.batchTimestamp = EpochTimestamp.toJSON(message.batchTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryBatch>, I>>(base?: I): TelemetryBatch {
    return TelemetryBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryBatch>, I>>(object: I): TelemetryBatch {
    const message = createBaseTelemetryBatch();
    message.events = object.events?.map((e) => TelemetryEvent.fromPartial(e)) || [];
    message.tickNumber = object.tickNumber ?? 0;
    message.batchTimestamp = (object.batchTimestamp !== undefined && object.batchTimestamp !== null)
      ? EpochTimestamp.fromPartial(object.batchTimestamp)
      : undefined;
    return message;
  },
};

function createBaseTelemetryFilter(): TelemetryFilter {
  return {
    npcIds: [],
    minSeverity: 0,
    includeStateChanges: false,
    includeMentalBreakdowns: false,
    includePermanentTraumas: false,
  };
}

export const TelemetryFilter = {
  encode(message: TelemetryFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.npcIds) {
      writer.uint32(10).string(v!);
    }
    if (message.minSeverity !== 0) {
      writer.uint32(16).int32(message.minSeverity);
    }
    if (message.includeStateChanges !== false) {
      writer.uint32(24).bool(message.includeStateChanges);
    }
    if (message.includeMentalBreakdowns !== false) {
      writer.uint32(32).bool(message.includeMentalBreakdowns);
    }
    if (message.includePermanentTraumas !== false) {
      writer.uint32(40).bool(message.includePermanentTraumas);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TelemetryFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minSeverity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeStateChanges = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeMentalBreakdowns = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includePermanentTraumas = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryFilter {
    return {
      npcIds: globalThis.Array.isArray(object?.npcIds) ? object.npcIds.map((e: any) => globalThis.String(e)) : [],
      minSeverity: isSet(object.minSeverity) ? telemetrySeverityFromJSON(object.minSeverity) : 0,
      includeStateChanges: isSet(object.includeStateChanges) ? globalThis.Boolean(object.includeStateChanges) : false,
      includeMentalBreakdowns: isSet(object.includeMentalBreakdowns)
        ? globalThis.Boolean(object.includeMentalBreakdowns)
        : false,
      includePermanentTraumas: isSet(object.includePermanentTraumas)
        ? globalThis.Boolean(object.includePermanentTraumas)
        : false,
    };
  },

  toJSON(message: TelemetryFilter): unknown {
    const obj: any = {};
    if (message.npcIds?.length) {
      obj.npcIds = message.npcIds;
    }
    if (message.minSeverity !== 0) {
      obj.minSeverity = telemetrySeverityToJSON(message.minSeverity);
    }
    if (message.includeStateChanges !== false) {
      obj.includeStateChanges = message.includeStateChanges;
    }
    if (message.includeMentalBreakdowns !== false) {
      obj.includeMentalBreakdowns = message.includeMentalBreakdowns;
    }
    if (message.includePermanentTraumas !== false) {
      obj.includePermanentTraumas = message.includePermanentTraumas;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryFilter>, I>>(base?: I): TelemetryFilter {
    return TelemetryFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryFilter>, I>>(object: I): TelemetryFilter {
    const message = createBaseTelemetryFilter();
    message.npcIds = object.npcIds?.map((e) => e) || [];
    message.minSeverity = object.minSeverity ?? 0;
    message.includeStateChanges = object.includeStateChanges ?? false;
    message.includeMentalBreakdowns = object.includeMentalBreakdowns ?? false;
    message.includePermanentTraumas = object.includePermanentTraumas ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
