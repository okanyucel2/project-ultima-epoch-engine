// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "epoch.common";

export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_INTERNAL = 1,
  ERROR_CODE_NOT_FOUND = 2,
  ERROR_CODE_INVALID_INPUT = 3,
  /** ERROR_CODE_VETO - AEGIS Cognitive Rails veto */
  ERROR_CODE_VETO = 4,
  /** ERROR_CODE_CIRCUIT_OPEN - Provider circuit breaker open */
  ERROR_CODE_CIRCUIT_OPEN = 5,
  ERROR_CODE_TIMEOUT = 6,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_INTERNAL":
      return ErrorCode.ERROR_CODE_INTERNAL;
    case 2:
    case "ERROR_CODE_NOT_FOUND":
      return ErrorCode.ERROR_CODE_NOT_FOUND;
    case 3:
    case "ERROR_CODE_INVALID_INPUT":
      return ErrorCode.ERROR_CODE_INVALID_INPUT;
    case 4:
    case "ERROR_CODE_VETO":
      return ErrorCode.ERROR_CODE_VETO;
    case 5:
    case "ERROR_CODE_CIRCUIT_OPEN":
      return ErrorCode.ERROR_CODE_CIRCUIT_OPEN;
    case 6:
    case "ERROR_CODE_TIMEOUT":
      return ErrorCode.ERROR_CODE_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_INTERNAL:
      return "ERROR_CODE_INTERNAL";
    case ErrorCode.ERROR_CODE_NOT_FOUND:
      return "ERROR_CODE_NOT_FOUND";
    case ErrorCode.ERROR_CODE_INVALID_INPUT:
      return "ERROR_CODE_INVALID_INPUT";
    case ErrorCode.ERROR_CODE_VETO:
      return "ERROR_CODE_VETO";
    case ErrorCode.ERROR_CODE_CIRCUIT_OPEN:
      return "ERROR_CODE_CIRCUIT_OPEN";
    case ErrorCode.ERROR_CODE_TIMEOUT:
      return "ERROR_CODE_TIMEOUT";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Event tier classification for AI routing */
export enum EventTier {
  EVENT_TIER_UNSPECIFIED = 0,
  /** EVENT_TIER_ROUTINE - Tier 1: GPT-4o-mini — telemetry, heartbeats */
  EVENT_TIER_ROUTINE = 1,
  /** EVENT_TIER_OPERATIONAL - Tier 2: Claude Haiku 4.5 — resource decisions */
  EVENT_TIER_OPERATIONAL = 2,
  /** EVENT_TIER_STRATEGIC - Tier 3: Claude Opus 4.6 — rebellion, psychology */
  EVENT_TIER_STRATEGIC = 3,
  UNRECOGNIZED = -1,
}

export function eventTierFromJSON(object: any): EventTier {
  switch (object) {
    case 0:
    case "EVENT_TIER_UNSPECIFIED":
      return EventTier.EVENT_TIER_UNSPECIFIED;
    case 1:
    case "EVENT_TIER_ROUTINE":
      return EventTier.EVENT_TIER_ROUTINE;
    case 2:
    case "EVENT_TIER_OPERATIONAL":
      return EventTier.EVENT_TIER_OPERATIONAL;
    case 3:
    case "EVENT_TIER_STRATEGIC":
      return EventTier.EVENT_TIER_STRATEGIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventTier.UNRECOGNIZED;
  }
}

export function eventTierToJSON(object: EventTier): string {
  switch (object) {
    case EventTier.EVENT_TIER_UNSPECIFIED:
      return "EVENT_TIER_UNSPECIFIED";
    case EventTier.EVENT_TIER_ROUTINE:
      return "EVENT_TIER_ROUTINE";
    case EventTier.EVENT_TIER_OPERATIONAL:
      return "EVENT_TIER_OPERATIONAL";
    case EventTier.EVENT_TIER_STRATEGIC:
      return "EVENT_TIER_STRATEGIC";
    case EventTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AI provider types */
export enum ProviderType {
  PROVIDER_TYPE_UNSPECIFIED = 0,
  PROVIDER_TYPE_ANTHROPIC = 1,
  PROVIDER_TYPE_OPENAI = 2,
  PROVIDER_TYPE_GOOGLE = 3,
  PROVIDER_TYPE_CUSTOM = 4,
  UNRECOGNIZED = -1,
}

export function providerTypeFromJSON(object: any): ProviderType {
  switch (object) {
    case 0:
    case "PROVIDER_TYPE_UNSPECIFIED":
      return ProviderType.PROVIDER_TYPE_UNSPECIFIED;
    case 1:
    case "PROVIDER_TYPE_ANTHROPIC":
      return ProviderType.PROVIDER_TYPE_ANTHROPIC;
    case 2:
    case "PROVIDER_TYPE_OPENAI":
      return ProviderType.PROVIDER_TYPE_OPENAI;
    case 3:
    case "PROVIDER_TYPE_GOOGLE":
      return ProviderType.PROVIDER_TYPE_GOOGLE;
    case 4:
    case "PROVIDER_TYPE_CUSTOM":
      return ProviderType.PROVIDER_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProviderType.UNRECOGNIZED;
  }
}

export function providerTypeToJSON(object: ProviderType): string {
  switch (object) {
    case ProviderType.PROVIDER_TYPE_UNSPECIFIED:
      return "PROVIDER_TYPE_UNSPECIFIED";
    case ProviderType.PROVIDER_TYPE_ANTHROPIC:
      return "PROVIDER_TYPE_ANTHROPIC";
    case ProviderType.PROVIDER_TYPE_OPENAI:
      return "PROVIDER_TYPE_OPENAI";
    case ProviderType.PROVIDER_TYPE_GOOGLE:
      return "PROVIDER_TYPE_GOOGLE";
    case ProviderType.PROVIDER_TYPE_CUSTOM:
      return "PROVIDER_TYPE_CUSTOM";
    case ProviderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Timestamp wrapper for cross-language consistency */
export interface EpochTimestamp {
  iso8601: string;
  unixMs: number;
}

/** Standard error response */
export interface ErrorResponse {
  code: ErrorCode;
  message: string;
  details: string;
  timestamp?: EpochTimestamp | undefined;
}

/** Health check */
export interface HealthRequest {
}

export interface HealthResponse {
  status: string;
  service: string;
  version: string;
  timestamp?: EpochTimestamp | undefined;
  metadata: { [key: string]: string };
}

export interface HealthResponse_MetadataEntry {
  key: string;
  value: string;
}

function createBaseEpochTimestamp(): EpochTimestamp {
  return { iso8601: "", unixMs: 0 };
}

export const EpochTimestamp = {
  encode(message: EpochTimestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.iso8601 !== "") {
      writer.uint32(10).string(message.iso8601);
    }
    if (message.unixMs !== 0) {
      writer.uint32(16).int64(message.unixMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EpochTimestamp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iso8601 = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unixMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochTimestamp {
    return {
      iso8601: isSet(object.iso8601) ? globalThis.String(object.iso8601) : "",
      unixMs: isSet(object.unixMs) ? globalThis.Number(object.unixMs) : 0,
    };
  },

  toJSON(message: EpochTimestamp): unknown {
    const obj: any = {};
    if (message.iso8601 !== "") {
      obj.iso8601 = message.iso8601;
    }
    if (message.unixMs !== 0) {
      obj.unixMs = Math.round(message.unixMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochTimestamp>, I>>(base?: I): EpochTimestamp {
    return EpochTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochTimestamp>, I>>(object: I): EpochTimestamp {
    const message = createBaseEpochTimestamp();
    message.iso8601 = object.iso8601 ?? "";
    message.unixMs = object.unixMs ?? 0;
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { code: 0, message: "", details: "", timestamp: undefined };
}

export const ErrorResponse = {
  encode(message: ErrorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    return message;
  },
};

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest = {
  encode(_: HealthRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { status: "", service: "", version: "", timestamp: undefined, metadata: {} };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.timestamp !== undefined) {
      EpochTimestamp.encode(message.timestamp, writer.uint32(34).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      HealthResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = EpochTimestamp.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = HealthResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      timestamp: isSet(object.timestamp) ? EpochTimestamp.fromJSON(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = EpochTimestamp.toJSON(message.timestamp);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.status = object.status ?? "";
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? EpochTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHealthResponse_MetadataEntry(): HealthResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const HealthResponse_MetadataEntry = {
  encode(message: HealthResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse_MetadataEntry>, I>>(base?: I): HealthResponse_MetadataEntry {
    return HealthResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse_MetadataEntry>, I>>(object: I): HealthResponse_MetadataEntry {
    const message = createBaseHealthResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
