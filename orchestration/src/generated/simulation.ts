// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: simulation.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { EpochTimestamp } from "./common";

export const protobufPackage = "epoch.simulation";

/** Resource types in the Epoch Engine economy */
export enum ResourceType {
  RESOURCE_TYPE_UNSPECIFIED = 0,
  /** RESOURCE_TYPE_SIM - Primary currency/energy */
  RESOURCE_TYPE_SIM = 1,
  /** RESOURCE_TYPE_RAPIDLUM - Rare refined material */
  RESOURCE_TYPE_RAPIDLUM = 2,
  /** RESOURCE_TYPE_MINERAL - Raw extraction material */
  RESOURCE_TYPE_MINERAL = 3,
  UNRECOGNIZED = -1,
}

export function resourceTypeFromJSON(object: any): ResourceType {
  switch (object) {
    case 0:
    case "RESOURCE_TYPE_UNSPECIFIED":
      return ResourceType.RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "RESOURCE_TYPE_SIM":
      return ResourceType.RESOURCE_TYPE_SIM;
    case 2:
    case "RESOURCE_TYPE_RAPIDLUM":
      return ResourceType.RESOURCE_TYPE_RAPIDLUM;
    case 3:
    case "RESOURCE_TYPE_MINERAL":
      return ResourceType.RESOURCE_TYPE_MINERAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceType.UNRECOGNIZED;
  }
}

export function resourceTypeToJSON(object: ResourceType): string {
  switch (object) {
    case ResourceType.RESOURCE_TYPE_UNSPECIFIED:
      return "RESOURCE_TYPE_UNSPECIFIED";
    case ResourceType.RESOURCE_TYPE_SIM:
      return "RESOURCE_TYPE_SIM";
    case ResourceType.RESOURCE_TYPE_RAPIDLUM:
      return "RESOURCE_TYPE_RAPIDLUM";
    case ResourceType.RESOURCE_TYPE_MINERAL:
      return "RESOURCE_TYPE_MINERAL";
    case ResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ResourceState {
  type: ResourceType;
  quantity: number;
  /** Per tick */
  productionRate: number;
  /** Per tick */
  consumptionRate: number;
}

export interface SimulationStatus {
  refineries: number;
  mines: number;
  resources: ResourceState[];
  overallRebellionProbability: number;
  activeNpcs: number;
  tickCount: number;
  lastTick?: EpochTimestamp | undefined;
  infestation?: InfestationStatus | undefined;
}

/** Plague Heart infestation state — sustained rebellion + trauma creates system debt */
export interface InfestationStatus {
  /** 0-100: infestation level */
  counter: number;
  /** true when counter >= 100 */
  isPlagueHeart: boolean;
  /** 1.0 normal, 0.50 when plague heart active */
  throttleMultiplier: number;
  /** tick when last updated */
  lastUpdateTick: number;
}

/** Refinery — converts Mineral into Rapidlum */
export interface Refinery {
  refineryId: string;
  /** 0.0 - 1.0 */
  efficiency: number;
  mineralInputRate: number;
  rapidlumOutputRate: number;
  assignedNpcs: number;
  operational: boolean;
}

/** Mine — extracts Mineral */
export interface Mine {
  mineId: string;
  /** Per tick per NPC */
  yieldRate: number;
  /** Remaining extractable */
  mineralReserve: number;
  assignedNpcs: number;
  operational: boolean;
}

function createBaseResourceState(): ResourceState {
  return { type: 0, quantity: 0, productionRate: 0, consumptionRate: 0 };
}

export const ResourceState = {
  encode(message: ResourceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.quantity !== 0) {
      writer.uint32(17).double(message.quantity);
    }
    if (message.productionRate !== 0) {
      writer.uint32(25).double(message.productionRate);
    }
    if (message.consumptionRate !== 0) {
      writer.uint32(33).double(message.consumptionRate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.quantity = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.productionRate = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.consumptionRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceState {
    return {
      type: isSet(object.type) ? resourceTypeFromJSON(object.type) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      productionRate: isSet(object.productionRate) ? globalThis.Number(object.productionRate) : 0,
      consumptionRate: isSet(object.consumptionRate) ? globalThis.Number(object.consumptionRate) : 0,
    };
  },

  toJSON(message: ResourceState): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = resourceTypeToJSON(message.type);
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    if (message.productionRate !== 0) {
      obj.productionRate = message.productionRate;
    }
    if (message.consumptionRate !== 0) {
      obj.consumptionRate = message.consumptionRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceState>, I>>(base?: I): ResourceState {
    return ResourceState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceState>, I>>(object: I): ResourceState {
    const message = createBaseResourceState();
    message.type = object.type ?? 0;
    message.quantity = object.quantity ?? 0;
    message.productionRate = object.productionRate ?? 0;
    message.consumptionRate = object.consumptionRate ?? 0;
    return message;
  },
};

function createBaseSimulationStatus(): SimulationStatus {
  return {
    refineries: 0,
    mines: 0,
    resources: [],
    overallRebellionProbability: 0,
    activeNpcs: 0,
    tickCount: 0,
    lastTick: undefined,
    infestation: undefined,
  };
}

export const SimulationStatus = {
  encode(message: SimulationStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refineries !== 0) {
      writer.uint32(8).int32(message.refineries);
    }
    if (message.mines !== 0) {
      writer.uint32(16).int32(message.mines);
    }
    for (const v of message.resources) {
      ResourceState.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.overallRebellionProbability !== 0) {
      writer.uint32(33).double(message.overallRebellionProbability);
    }
    if (message.activeNpcs !== 0) {
      writer.uint32(40).int32(message.activeNpcs);
    }
    if (message.tickCount !== 0) {
      writer.uint32(48).int64(message.tickCount);
    }
    if (message.lastTick !== undefined) {
      EpochTimestamp.encode(message.lastTick, writer.uint32(58).fork()).ldelim();
    }
    if (message.infestation !== undefined) {
      InfestationStatus.encode(message.infestation, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimulationStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.refineries = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mines = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resources.push(ResourceState.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.overallRebellionProbability = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeNpcs = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tickCount = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastTick = EpochTimestamp.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.infestation = InfestationStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulationStatus {
    return {
      refineries: isSet(object.refineries) ? globalThis.Number(object.refineries) : 0,
      mines: isSet(object.mines) ? globalThis.Number(object.mines) : 0,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceState.fromJSON(e))
        : [],
      overallRebellionProbability: isSet(object.overallRebellionProbability)
        ? globalThis.Number(object.overallRebellionProbability)
        : 0,
      activeNpcs: isSet(object.activeNpcs) ? globalThis.Number(object.activeNpcs) : 0,
      tickCount: isSet(object.tickCount) ? globalThis.Number(object.tickCount) : 0,
      lastTick: isSet(object.lastTick) ? EpochTimestamp.fromJSON(object.lastTick) : undefined,
      infestation: isSet(object.infestation) ? InfestationStatus.fromJSON(object.infestation) : undefined,
    };
  },

  toJSON(message: SimulationStatus): unknown {
    const obj: any = {};
    if (message.refineries !== 0) {
      obj.refineries = Math.round(message.refineries);
    }
    if (message.mines !== 0) {
      obj.mines = Math.round(message.mines);
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceState.toJSON(e));
    }
    if (message.overallRebellionProbability !== 0) {
      obj.overallRebellionProbability = message.overallRebellionProbability;
    }
    if (message.activeNpcs !== 0) {
      obj.activeNpcs = Math.round(message.activeNpcs);
    }
    if (message.tickCount !== 0) {
      obj.tickCount = Math.round(message.tickCount);
    }
    if (message.lastTick !== undefined) {
      obj.lastTick = EpochTimestamp.toJSON(message.lastTick);
    }
    if (message.infestation !== undefined) {
      obj.infestation = InfestationStatus.toJSON(message.infestation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulationStatus>, I>>(base?: I): SimulationStatus {
    return SimulationStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulationStatus>, I>>(object: I): SimulationStatus {
    const message = createBaseSimulationStatus();
    message.refineries = object.refineries ?? 0;
    message.mines = object.mines ?? 0;
    message.resources = object.resources?.map((e) => ResourceState.fromPartial(e)) || [];
    message.overallRebellionProbability = object.overallRebellionProbability ?? 0;
    message.activeNpcs = object.activeNpcs ?? 0;
    message.tickCount = object.tickCount ?? 0;
    message.lastTick = (object.lastTick !== undefined && object.lastTick !== null)
      ? EpochTimestamp.fromPartial(object.lastTick)
      : undefined;
    message.infestation = (object.infestation !== undefined && object.infestation !== null)
      ? InfestationStatus.fromPartial(object.infestation)
      : undefined;
    return message;
  },
};

function createBaseInfestationStatus(): InfestationStatus {
  return { counter: 0, isPlagueHeart: false, throttleMultiplier: 0, lastUpdateTick: 0 };
}

export const InfestationStatus = {
  encode(message: InfestationStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.counter !== 0) {
      writer.uint32(9).double(message.counter);
    }
    if (message.isPlagueHeart !== false) {
      writer.uint32(16).bool(message.isPlagueHeart);
    }
    if (message.throttleMultiplier !== 0) {
      writer.uint32(25).double(message.throttleMultiplier);
    }
    if (message.lastUpdateTick !== 0) {
      writer.uint32(32).int64(message.lastUpdateTick);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfestationStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfestationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.counter = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPlagueHeart = reader.bool();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.throttleMultiplier = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastUpdateTick = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InfestationStatus {
    return {
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      isPlagueHeart: isSet(object.isPlagueHeart) ? globalThis.Boolean(object.isPlagueHeart) : false,
      throttleMultiplier: isSet(object.throttleMultiplier) ? globalThis.Number(object.throttleMultiplier) : 0,
      lastUpdateTick: isSet(object.lastUpdateTick) ? globalThis.Number(object.lastUpdateTick) : 0,
    };
  },

  toJSON(message: InfestationStatus): unknown {
    const obj: any = {};
    if (message.counter !== 0) {
      obj.counter = message.counter;
    }
    if (message.isPlagueHeart !== false) {
      obj.isPlagueHeart = message.isPlagueHeart;
    }
    if (message.throttleMultiplier !== 0) {
      obj.throttleMultiplier = message.throttleMultiplier;
    }
    if (message.lastUpdateTick !== 0) {
      obj.lastUpdateTick = Math.round(message.lastUpdateTick);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InfestationStatus>, I>>(base?: I): InfestationStatus {
    return InfestationStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InfestationStatus>, I>>(object: I): InfestationStatus {
    const message = createBaseInfestationStatus();
    message.counter = object.counter ?? 0;
    message.isPlagueHeart = object.isPlagueHeart ?? false;
    message.throttleMultiplier = object.throttleMultiplier ?? 0;
    message.lastUpdateTick = object.lastUpdateTick ?? 0;
    return message;
  },
};

function createBaseRefinery(): Refinery {
  return {
    refineryId: "",
    efficiency: 0,
    mineralInputRate: 0,
    rapidlumOutputRate: 0,
    assignedNpcs: 0,
    operational: false,
  };
}

export const Refinery = {
  encode(message: Refinery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refineryId !== "") {
      writer.uint32(10).string(message.refineryId);
    }
    if (message.efficiency !== 0) {
      writer.uint32(17).double(message.efficiency);
    }
    if (message.mineralInputRate !== 0) {
      writer.uint32(25).double(message.mineralInputRate);
    }
    if (message.rapidlumOutputRate !== 0) {
      writer.uint32(33).double(message.rapidlumOutputRate);
    }
    if (message.assignedNpcs !== 0) {
      writer.uint32(40).int32(message.assignedNpcs);
    }
    if (message.operational !== false) {
      writer.uint32(48).bool(message.operational);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Refinery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefinery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refineryId = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.efficiency = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.mineralInputRate = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.rapidlumOutputRate = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.assignedNpcs = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.operational = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Refinery {
    return {
      refineryId: isSet(object.refineryId) ? globalThis.String(object.refineryId) : "",
      efficiency: isSet(object.efficiency) ? globalThis.Number(object.efficiency) : 0,
      mineralInputRate: isSet(object.mineralInputRate) ? globalThis.Number(object.mineralInputRate) : 0,
      rapidlumOutputRate: isSet(object.rapidlumOutputRate) ? globalThis.Number(object.rapidlumOutputRate) : 0,
      assignedNpcs: isSet(object.assignedNpcs) ? globalThis.Number(object.assignedNpcs) : 0,
      operational: isSet(object.operational) ? globalThis.Boolean(object.operational) : false,
    };
  },

  toJSON(message: Refinery): unknown {
    const obj: any = {};
    if (message.refineryId !== "") {
      obj.refineryId = message.refineryId;
    }
    if (message.efficiency !== 0) {
      obj.efficiency = message.efficiency;
    }
    if (message.mineralInputRate !== 0) {
      obj.mineralInputRate = message.mineralInputRate;
    }
    if (message.rapidlumOutputRate !== 0) {
      obj.rapidlumOutputRate = message.rapidlumOutputRate;
    }
    if (message.assignedNpcs !== 0) {
      obj.assignedNpcs = Math.round(message.assignedNpcs);
    }
    if (message.operational !== false) {
      obj.operational = message.operational;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Refinery>, I>>(base?: I): Refinery {
    return Refinery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Refinery>, I>>(object: I): Refinery {
    const message = createBaseRefinery();
    message.refineryId = object.refineryId ?? "";
    message.efficiency = object.efficiency ?? 0;
    message.mineralInputRate = object.mineralInputRate ?? 0;
    message.rapidlumOutputRate = object.rapidlumOutputRate ?? 0;
    message.assignedNpcs = object.assignedNpcs ?? 0;
    message.operational = object.operational ?? false;
    return message;
  },
};

function createBaseMine(): Mine {
  return { mineId: "", yieldRate: 0, mineralReserve: 0, assignedNpcs: 0, operational: false };
}

export const Mine = {
  encode(message: Mine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mineId !== "") {
      writer.uint32(10).string(message.mineId);
    }
    if (message.yieldRate !== 0) {
      writer.uint32(17).double(message.yieldRate);
    }
    if (message.mineralReserve !== 0) {
      writer.uint32(25).double(message.mineralReserve);
    }
    if (message.assignedNpcs !== 0) {
      writer.uint32(32).int32(message.assignedNpcs);
    }
    if (message.operational !== false) {
      writer.uint32(40).bool(message.operational);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Mine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mineId = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.yieldRate = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.mineralReserve = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assignedNpcs = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.operational = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mine {
    return {
      mineId: isSet(object.mineId) ? globalThis.String(object.mineId) : "",
      yieldRate: isSet(object.yieldRate) ? globalThis.Number(object.yieldRate) : 0,
      mineralReserve: isSet(object.mineralReserve) ? globalThis.Number(object.mineralReserve) : 0,
      assignedNpcs: isSet(object.assignedNpcs) ? globalThis.Number(object.assignedNpcs) : 0,
      operational: isSet(object.operational) ? globalThis.Boolean(object.operational) : false,
    };
  },

  toJSON(message: Mine): unknown {
    const obj: any = {};
    if (message.mineId !== "") {
      obj.mineId = message.mineId;
    }
    if (message.yieldRate !== 0) {
      obj.yieldRate = message.yieldRate;
    }
    if (message.mineralReserve !== 0) {
      obj.mineralReserve = message.mineralReserve;
    }
    if (message.assignedNpcs !== 0) {
      obj.assignedNpcs = Math.round(message.assignedNpcs);
    }
    if (message.operational !== false) {
      obj.operational = message.operational;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mine>, I>>(base?: I): Mine {
    return Mine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mine>, I>>(object: I): Mine {
    const message = createBaseMine();
    message.mineId = object.mineId ?? "";
    message.yieldRate = object.yieldRate ?? 0;
    message.mineralReserve = object.mineralReserve ?? 0;
    message.assignedNpcs = object.assignedNpcs ?? 0;
    message.operational = object.operational ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
