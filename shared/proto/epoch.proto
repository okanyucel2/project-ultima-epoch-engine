syntax = "proto3";

package epoch;

import "common.proto";
import "npc.proto";
import "simulation.proto";
import "telemetry.proto";

option go_package = "github.com/okanyucel2/project-ultima-epoch-engine/logistics/internal/generated/epochpb";

// =============================================================================
// REBELLION SERVICE — Core NPC rebellion mechanics
// =============================================================================

service RebellionService {
  // Get rebellion probability for a specific NPC
  rpc GetRebellionProbability(RebellionRequest) returns (RebellionResponse);

  // Process an NPC action and return updated state
  rpc ProcessNPCAction(ProcessActionRequest) returns (ProcessActionResponse);

  // Stream real-time NPC events (server-side streaming)
  rpc StreamNPCEvents(NPCEventFilter) returns (stream NPCEventStream);
}

message RebellionRequest {
  string npc_id = 1;
  bool include_factors = 2;  // Return detailed breakdown
}

message RebellionResponse {
  string npc_id = 1;
  double probability = 2;    // 0.0 - 1.0
  RebellionFactors factors = 3;
  bool threshold_exceeded = 4;
  epoch.common.EpochTimestamp calculated_at = 5;
}

message RebellionFactors {
  double base = 1;            // 0.05 baseline
  double trauma_modifier = 2; // avgTrauma * 0.3
  double efficiency_modifier = 3; // (1 - efficiency) * 0.3
  double morale_modifier = 4; // (1 - morale) * 0.2
}

message ProcessActionRequest {
  epoch.npc.NPCAction action = 1;
  bool dry_run = 2;           // Calculate effects without applying
}

message ProcessActionResponse {
  epoch.npc.NPCState updated_state = 1;
  double rebellion_delta = 2; // Change in rebellion probability
  bool rebellion_triggered = 3;
  epoch.npc.RebellionEvent rebellion_event = 4; // Set if triggered
}

message NPCEventFilter {
  repeated string npc_ids = 1;  // Empty = all NPCs
  double min_rebellion_probability = 2; // Only events above threshold
}

message NPCEventStream {
  string event_type = 1;     // "state_change", "rebellion", "action_processed"
  epoch.npc.NPCState state = 2;
  epoch.npc.RebellionEvent rebellion = 3;
  epoch.common.EpochTimestamp timestamp = 4;
}

// =============================================================================
// SIMULATION SERVICE — Resource economy and logistics
// =============================================================================

service SimulationService {
  // Get current simulation status
  rpc GetSimulationStatus(SimStatusRequest) returns (epoch.simulation.SimulationStatus);

  // Update resource allocation
  rpc UpdateResourceAllocation(ResourceAllocationRequest) returns (ResourceAllocationResponse);

  // Advance simulation by N ticks
  rpc AdvanceSimulation(AdvanceRequest) returns (AdvanceResponse);
}

message SimStatusRequest {
  bool include_details = 1;
}

message ResourceAllocationRequest {
  string target_id = 1;      // Refinery or Mine ID
  int32 npc_count = 2;       // NPCs to assign
  epoch.simulation.ResourceType resource_type = 3;
}

message ResourceAllocationResponse {
  bool success = 1;
  string message = 2;
  epoch.simulation.SimulationStatus updated_status = 3;
}

message AdvanceRequest {
  int32 ticks = 1;            // Number of ticks to advance
}

message AdvanceResponse {
  epoch.simulation.SimulationStatus status = 1;
  repeated NPCEventStream events = 2; // Events generated during ticks
  epoch.telemetry.TelemetryBatch telemetry = 3; // Telemetry events from tick
}

// =============================================================================
// TELEMETRY SERVICE — 0ms real-time NPC psychological/physical event stream
// =============================================================================
// Carries The Alters-style mental breakdowns and Battle Brothers-style
// permanent traumas as millisecond-precision events for dashboard karmic
// feedback visualization and Neo4j memory persistence.

service TelemetryService {
  // Stream real-time telemetry events (server-side streaming)
  // Client subscribes with filter, server pushes events as they occur
  rpc StreamTelemetry(epoch.telemetry.TelemetryFilter) returns (stream epoch.telemetry.TelemetryEvent);

  // Get recent telemetry events (unary — for dashboard initial load)
  rpc GetRecentTelemetry(RecentTelemetryRequest) returns (epoch.telemetry.TelemetryBatch);

  // Report a telemetry event (unary — for simulation engine to emit events)
  rpc ReportTelemetryEvent(epoch.telemetry.TelemetryEvent) returns (TelemetryAck);
}

message RecentTelemetryRequest {
  int32 limit = 1;                 // Max events to return (default 50)
  string npc_id = 2;              // Filter by NPC (empty = all)
  epoch.telemetry.TelemetrySeverity min_severity = 3;
}

message TelemetryAck {
  string event_id = 1;
  bool accepted = 2;
  string rejection_reason = 3;    // Set if not accepted (e.g., AEGIS veto)
}

// =============================================================================
// CLEANSING SERVICE — Sheriff Protocol plague heart purge operations
// =============================================================================

service CleansingService {
  // Deploy a cleansing operation against an active Plague Heart
  rpc DeployCleansingOperation(CleansingRequest) returns (CleansingResponse);
}

message CleansingRequest {
  repeated string npc_ids = 1;    // Empty = auto-select warriors/guards
}

message CleansingResponse {
  bool success = 1;
  double success_rate = 2;
  int32 participant_count = 3;
  repeated string participant_ids = 4;
  double rolled_value = 5;
  CleansingFactors factors = 6;
  string error_message = 7;
}

message CleansingFactors {
  double base = 1;
  double avg_morale = 2;
  double morale_contribution = 3;
  double avg_trauma = 4;
  double trauma_penalty = 5;
  double avg_confidence = 6;
  double confidence_contribution = 7;
}
